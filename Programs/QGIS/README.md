---
title: QGIS
tags: studies, program
use: Documentation
languages: NULL
dependences: QGIS
---

> [!] Is important to know that I've only copied some points of the original documentation, I'll update the informations only with free time

<details> <summary>Full website root</summary>

- [1. Course Introduction](https://docs.qgis.org/3.28/en/docs/training_manual/foreword/index.html)
    - [1.1. Foreword](https://docs.qgis.org/3.28/en/docs/training_manual/foreword/foreword.html)
    - [1.2. About the exercises](https://docs.qgis.org/3.28/en/docs/training_manual/foreword/intro.html)
- [2. Module: Creating and Exploring a Basic Map](https://docs.qgis.org/3.28/en/docs/training_manual/basic_map/index.html)
    - [2.1. Lesson: An Overview of the Interface](https://docs.qgis.org/3.28/en/docs/training_manual/basic_map/overview.html)
    - [2.2. Lesson: Adding your first layers](https://docs.qgis.org/3.28/en/docs/training_manual/basic_map/preparation.html)
    - [2.3. Lesson: Navigating the Map Canvas](https://docs.qgis.org/3.28/en/docs/training_manual/basic_map/mapviewnavigation.html)
    - [2.4. Lesson: Symbology](https://docs.qgis.org/3.28/en/docs/training_manual/basic_map/symbology.html)
- [3. Module: Classifying Vector Data](https://docs.qgis.org/3.28/en/docs/training_manual/vector_classification/index.html)
    - [3.1. Lesson: Vector Attribute Data](https://docs.qgis.org/3.28/en/docs/training_manual/vector_classification/attribute_data.html)
    - [3.2. Lesson: Labels](https://docs.qgis.org/3.28/en/docs/training_manual/vector_classification/label_tool.html)
    - [3.3. Lesson: Classification](https://docs.qgis.org/3.28/en/docs/training_manual/vector_classification/classification.html)
- [4. Module: Laying out the Maps](https://docs.qgis.org/3.28/en/docs/training_manual/map_composer/index.html)
    - [4.1. Lesson: Using Print Layout](https://docs.qgis.org/3.28/en/docs/training_manual/map_composer/map_composer.html)
    - [4.2. Lesson: Creating a Dynamic Print Layout](https://docs.qgis.org/3.28/en/docs/training_manual/map_composer/dynamic_layout.html)
    - [4.3. Assignment 1](https://docs.qgis.org/3.28/en/docs/training_manual/map_composer/day_1_assignment.html)
- [5. Module: Creating Vector Data](https://docs.qgis.org/3.28/en/docs/training_manual/create_vector_data/index.html)
    - [5.1. Lesson: Creating a New Vector Dataset](https://docs.qgis.org/3.28/en/docs/training_manual/create_vector_data/create_new_vector.html)
    - [5.2. Lesson: Feature Topology](https://docs.qgis.org/3.28/en/docs/training_manual/create_vector_data/topo_editing.html)
    - [5.3. Lesson: Forms](https://docs.qgis.org/3.28/en/docs/training_manual/create_vector_data/forms.html)
    - [5.4. Lesson: Actions]()
- [6. Module: Vector Analysis](https://docs.qgis.org/3.28/en/docs/training_manual/vector_analysis/index.html)
    - [6.1. Lesson: Reprojecting and Transforming Data](https://docs.qgis.org/3.28/en/docs/training_manual/vector_analysis/reproject_transform.html)
    - [6.2. Lesson: Vector Analysis](https://docs.qgis.org/3.28/en/docs/training_manual/vector_analysis/basic_analysis.html)
    - [6.3. Lesson: Network Analysis](https://docs.qgis.org/3.28/en/docs/training_manual/vector_analysis/network_analysis.html)
    - [6.4. Lesson: Spatial Statistics](https://docs.qgis.org/3.28/en/docs/training_manual/vector_analysis/spatial_statistics.html)
- [7. Module: Rasters](https://docs.qgis.org/3.28/en/docs/training_manual/rasters/index.html)
    - [7.1. Lesson: Working with Raster Data](https://docs.qgis.org/3.28/en/docs/training_manual/rasters/data_manipulation.html)
    - [7.2. Lesson: Changing Raster Symbology](https://docs.qgis.org/3.28/en/docs/training_manual/rasters/changing_symbology.html)
    - [7.3. Lesson: Terrain Analysis](https://docs.qgis.org/3.28/en/docs/training_manual/rasters/terrain_analysis.html)
- [8. Module: Completing the Analysis](https://docs.qgis.org/3.28/en/docs/training_manual/complete_analysis/index.html)
    - [8.1. Lesson: Raster to Vector Conversion](https://docs.qgis.org/3.28/en/docs/training_manual/complete_analysis/raster_to_vector.html)
    - [8.2. Lesson: Combining the Analyses](https://docs.qgis.org/3.28/en/docs/training_manual/complete_analysis/analysis_combination.html)
    - [8.3. Assignment](https://docs.qgis.org/3.28/en/docs/training_manual/complete_analysis/assignment.html)
    - [8.4. Lesson: Supplementary Exercise](https://docs.qgis.org/3.28/en/docs/training_manual/complete_analysis/analysis_exercise.html)
- [9. Module: Plugins](https://docs.qgis.org/3.28/en/docs/training_manual/qgis_plugins/index.html)
    - [9.1. Lesson: Installing and Managing Plugins](https://docs.qgis.org/3.28/en/docs/training_manual/qgis_plugins/fetching_plugins.html)
    - [9.2. Lesson: Useful QGIS Plugins](https://docs.qgis.org/3.28/en/docs/training_manual/qgis_plugins/plugin_examples.html)
- [10. Module: Online Resources](https://docs.qgis.org/3.28/en/docs/training_manual/online_resources/index.html)
    - [10.1. Lesson: Web Mapping Services](https://docs.qgis.org/3.28/en/docs/training_manual/online_resources/wms.html)
    - [10.2. Lesson: Web Feature Services](https://docs.qgis.org/3.28/en/docs/training_manual/online_resources/wfs.html)
- [11. Module: QGIS Server](https://docs.qgis.org/3.28/en/docs/training_manual/qgis_server/index.html)
    - [11.1. Lesson: Install QGIS Server](https://docs.qgis.org/3.28/en/docs/training_manual/qgis_server/install.html)
    - [11.2. Lesson: Serving WMS](https://docs.qgis.org/3.28/en/docs/training_manual/qgis_server/wms.html)
- [12. Module: GRASS](https://docs.qgis.org/3.28/en/docs/training_manual/grass/index.html)
    - [12.1. Lesson: GRASS Setup](https://docs.qgis.org/3.28/en/docs/training_manual/grass/grass_setup.html)
    - [12.2. Lesson: GRASS Tools](https://docs.qgis.org/3.28/en/docs/training_manual/grass/grass_tools.html)
- [13. Module: Assessment](https://docs.qgis.org/3.28/en/docs/training_manual/assessment/index.html)
    - [13.1. Create a base map](https://docs.qgis.org/3.28/en/docs/training_manual/assessment/index.html#create-a-base-map)
    - [13.2. Analyze the data](https://docs.qgis.org/3.28/en/docs/training_manual/assessment/index.html#analyze-the-data)
    - [13.3. Final Map](https://docs.qgis.org/3.28/en/docs/training_manual/assessment/index.html#final-map)
- [14. Module: Forestry Application](https://docs.qgis.org/3.28/en/docs/training_manual/forestry/index.html)
    - [14.1. Lesson: Forestry Module Presentation](https://docs.qgis.org/3.28/en/docs/training_manual/forestry/forestry_intro.html)
    - [14.2. Lesson: Georeferencing a Map](https://docs.qgis.org/3.28/en/docs/training_manual/forestry/map_georeferencing.html)
    - [14.3. Lesson: Digitizing Forest Stands](https://docs.qgis.org/3.28/en/docs/training_manual/forestry/stands_digitizing.html)
    - [14.4. Lesson: Updating Forest Stands](https://docs.qgis.org/3.28/en/docs/training_manual/forestry/updating_stands.html)
    - [14.5. Lesson: Systematic Sampling Design](https://docs.qgis.org/3.28/en/docs/training_manual/forestry/systematic_sampling.html)
    - [14.6. Lesson: Creating Detailed Maps with the Atlas Tool](https://docs.qgis.org/3.28/en/docs/training_manual/forestry/forest_maps.html)
    - [14.7. Lesson: Calculating the Forest Parameters](https://docs.qgis.org/3.28/en/docs/training_manual/forestry/parameters_calculation.html)
    - [14.8. Lesson: DEM from LiDAR Data](https://docs.qgis.org/3.28/en/docs/training_manual/forestry/basic_lidar.html)
    - [14.9. Lesson: Map Presentation](https://docs.qgis.org/3.28/en/docs/training_manual/forestry/results_map.html)
- [15. Module: Database Concepts with PostgreSQL](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/index.html)
    - [15.1. Lesson: Introduction to Databases](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/db_intro.html)
    - [15.2. Lesson: Implementing the Data Model](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/data_model.html)
    - [15.3. Lesson: Adding Data to the Model](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/adding_data.html)
    - [15.4. Lesson: Queries](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/queries.html)
    - [15.5. Lesson: Views](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/views.html)
    - [15.6. Lesson: Rules](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/rules.html)
- [16. Module: Spatial Database Concepts with PostGIS](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/index.html)
    - [16.1. Lesson: PostGIS Setup](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/spatial_functions.html)
    - [16.2. Lesson: Simple Feature Model](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/simple_feature_model.html)
    - [16.3. Lesson: Import and Export](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/import_export.html)
    - [16.4. Lesson: Spatial Queries](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/spatial_queries.html)
    - [16.5. Lesson: Geometry Construction](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/geometry.html)
- [17. The QGIS processing guide](https://docs.qgis.org/3.28/en/docs/training_manual/processing/index.html)
    - [17.1. Introduction](https://docs.qgis.org/3.28/en/docs/training_manual/processing/intro.html)
    - [17.2. An important warning before starting](https://docs.qgis.org/3.28/en/docs/training_manual/processing/warning.html)
    - [17.3. Setting-up the processing framework](https://docs.qgis.org/3.28/en/docs/training_manual/processing/set_up.html)
    - [17.4. Running our first algorithm. The toolbox](https://docs.qgis.org/3.28/en/docs/training_manual/processing/first_alg.html)
    - [17.5. More algorithms and data types](https://docs.qgis.org/3.28/en/docs/training_manual/processing/second_alg.html)
    - [17.6. CRSs. Reprojecting](https://docs.qgis.org/3.28/en/docs/training_manual/processing/crs.html)
    - [17.7. Selection](https://docs.qgis.org/3.28/en/docs/training_manual/processing/selection.html)
    - [17.8. Running an external algorithm](https://docs.qgis.org/3.28/en/docs/training_manual/processing/first_saga_alg.html)
    - [17.9. The processing log](https://docs.qgis.org/3.28/en/docs/training_manual/processing/log.html)
    - [17.10. The raster calculator. No-data values](https://docs.qgis.org/3.28/en/docs/training_manual/processing/no_data.html)
    - [17.11. Vector calculator](https://docs.qgis.org/3.28/en/docs/training_manual/processing/vector_calculator.html)
    - [17.12. Defining extents](https://docs.qgis.org/3.28/en/docs/training_manual/processing/extents.html)
    - [17.13. HTML outputs](https://docs.qgis.org/3.28/en/docs/training_manual/processing/html.html)
    - [17.14. First analysis example](https://docs.qgis.org/3.28/en/docs/training_manual/processing/john_snow.html)
    - [17.15. Clipping and merging raster layers](https://docs.qgis.org/3.28/en/docs/training_manual/processing/cutting_merging.html)
    - [17.16. Hydrological analysis](https://docs.qgis.org/3.28/en/docs/training_manual/processing/hydro.html)
    - [17.17. Starting with the graphical modeler](https://docs.qgis.org/3.28/en/docs/training_manual/processing/modeler_twi.html)
    - [17.18. More complex models](https://docs.qgis.org/3.28/en/docs/training_manual/processing/modeler_hydro.html)
    - [17.19. Numeric calculations in the modeler](https://docs.qgis.org/3.28/en/docs/training_manual/processing/modeler_hydro_calculator.html)
    - [17.20. A model within a model](https://docs.qgis.org/3.28/en/docs/training_manual/processing/modeler_hydro_twi.html)
    - [17.21. Using modeler-only tools for creating a model](https://docs.qgis.org/3.28/en/docs/training_manual/processing/modeler_only.html)
    - [17.22. Interpolation](https://docs.qgis.org/3.28/en/docs/training_manual/processing/interpolation.html)
    - [17.23. More interpolation](https://docs.qgis.org/3.28/en/docs/training_manual/processing/interpolation_cross.html)
    - [17.24. Iterative execution of algorithms](https://docs.qgis.org/3.28/en/docs/training_manual/processing/iterative.html)
    - [17.25. More iterative execution of algorithms](https://docs.qgis.org/3.28/en/docs/training_manual/processing/iterative_model.html)
    - [17.26. The batch processing interface](https://docs.qgis.org/3.28/en/docs/training_manual/processing/batch_conversion.html)
    - [17.27. Models in the batch processing interface](https://docs.qgis.org/3.28/en/docs/training_manual/processing/batch_modeler.html)
    - [17.28. Pre- and post-execution script hooks](https://docs.qgis.org/3.28/en/docs/training_manual/processing/hooks.html)
    - [17.29. Other programs](https://docs.qgis.org/3.28/en/docs/training_manual/processing/more_backends.html)
    - [17.30. Interpolation and contouring](https://docs.qgis.org/3.28/en/docs/training_manual/processing/interp_contour.html)
    - [17.31. Vector simplification and smoothing](https://docs.qgis.org/3.28/en/docs/training_manual/processing/generalize.html)
    - [17.32. Planning a solar farm](https://docs.qgis.org/3.28/en/docs/training_manual/processing/solar.html)
    - [17.33. Use R scripts in Processing](https://docs.qgis.org/3.28/en/docs/training_manual/processing/r_intro.html)
    - [17.34. Predicting landslides](https://docs.qgis.org/3.28/en/docs/training_manual/processing/geomorpho.html)
- [18. Module: Using Spatial Databases in QGIS](https://docs.qgis.org/3.28/en/docs/training_manual/databases/index.html)
    - [18.1. Lesson: Working with Databases in the QGIS Browser](https://docs.qgis.org/3.28/en/docs/training_manual/databases/db_browser.html)
    - [18.2. Lesson: Using DB Manager to work with Spatial Databases in QGIS](https://docs.qgis.org/3.28/en/docs/training_manual/databases/db_manager.html)
    - [18.3. Lesson: Working with SpatiaLite databases in QGIS](https://docs.qgis.org/3.28/en/docs/training_manual/databases/spatialite.html)
- [19. Appendix: Contributing To This Manual](https://docs.qgis.org/3.28/en/docs/training_manual/appendix/contribute.html)
    - [19.1. Downloading Resources](https://docs.qgis.org/3.28/en/docs/training_manual/appendix/contribute.html#downloading-resources)
    - [19.2. Manual Format](https://docs.qgis.org/3.28/en/docs/training_manual/appendix/contribute.html#manual-format)
    - [19.3. Adding a Module](https://docs.qgis.org/3.28/en/docs/training_manual/appendix/contribute.html#adding-a-module)
    - [19.4. Adding a Lesson](https://docs.qgis.org/3.28/en/docs/training_manual/appendix/contribute.html#adding-a-lesson)
    - [19.5. Adding a Section](https://docs.qgis.org/3.28/en/docs/training_manual/appendix/contribute.html#adding-a-section)
    - [19.6. Add a Conclusion](https://docs.qgis.org/3.28/en/docs/training_manual/appendix/contribute.html#add-a-conclusion)
    - [19.7. Add a Further Reading Section](https://docs.qgis.org/3.28/en/docs/training_manual/appendix/contribute.html#add-a-further-reading-section)
    - [19.8. Add a What’s Next Section](https://docs.qgis.org/3.28/en/docs/training_manual/appendix/contribute.html#add-a-what-s-next-section)
    - [19.9. Using Markup](https://docs.qgis.org/3.28/en/docs/training_manual/appendix/contribute.html#using-markup)
    - [19.10. Thank You!](https://docs.qgis.org/3.28/en/docs/training_manual/appendix/contribute.html#thank-you)
- [20. Preparing Exercise Data](https://docs.qgis.org/3.28/en/docs/training_manual/appendix/preparing_data.html)
    - [20.1. Try Yourself Create OSM based vector files](https://docs.qgis.org/3.28/en/docs/training_manual/appendix/preparing_data.html#hard-ty-create-osm-based-vector-files)
    - [20.2. Try Yourself Create SRTM DEM tiff files](https://docs.qgis.org/3.28/en/docs/training_manual/appendix/preparing_data.html#hard-ty-create-srtm-dem-tiff-files)
    - [20.3. Try Yourself Create imagery tiff files](https://docs.qgis.org/3.28/en/docs/training_manual/appendix/preparing_data.html#hard-ty-create-imagery-tiff-files)
    - [20.4. Try Yourself Replace tokens](https://docs.qgis.org/3.28/en/docs/training_manual/appendix/preparing_data.html#basic-ty-replace-tokens)

</details>

---

<details> <summary> Actual Table of Contents </summary>

- [5.4. Lesson: Actions #](#54-lesson-actions-)
  - [5.4.1.  Follow Along: Add a Field for Images #](#541--follow-along-add-a-field-for-images-)
  - [5.4.2.  Follow Along: Creating an Action #](#542--follow-along-creating-an-action-)
  - [5.4.3.  Follow Along: Searching the Internet #](#543--follow-along-searching-the-internet-)
  - [5.4.4.  Follow Along: Open a Webpage Directly in QGIS #](#544--follow-along-open-a-webpage-directly-in-qgis-)
  - [5.4.5. In Conclusion #](#545-in-conclusion-)
  - [5.4.6. What’s Next? #](#546-whats-next-)
- [6.3. Lesson: Network Analysis #](#63-lesson-network-analysis-)
  - [6.3.1.  Follow Along: The Tools and the Data #](#631--follow-along-the-tools-and-the-data-)
  - [6.3.2.  Calculate the shortest path (point to point) #](#632--calculate-the-shortest-path-point-to-point-)
  - [6.3.3.  Try Yourself Fastest path #](#633--try-yourself-fastest-path-)
  - [6.3.4.  Follow Along: Advanced options #](#634--follow-along-advanced-options-)
  - [6.3.5.  Shortest path with speed limit #](#635--shortest-path-with-speed-limit-)
  - [6.3.6.  Service area (from layer) #](#636--service-area-from-layer-)
  - [6.3.7. In Conclusion #](#637-in-conclusion-)
  - [6.3.8. What’s Next? #](#638-whats-next-)
- [11.1. Lesson: Install QGIS Server #](#111-lesson-install-qgis-server-)
  - [11.1.1.  Follow Along: Install from packages #](#1111--follow-along-install-from-packages-)
  - [11.1.2.  Follow Along: QGIS Server Executable #](#1112--follow-along-qgis-server-executable-)
  - [11.1.3.  HTTP Server Configuration #](#1113--http-server-configuration-)
  - [11.1.4.  Follow Along: Create another virtual host #](#1114--follow-along-create-another-virtual-host-)
  - [11.1.5. In Conclusion #](#1115-in-conclusion-)
  - [11.1.6. What’s Next? #](#1116-whats-next-)
- [15.2. Lesson: Implementing the Data Model #](#152-lesson-implementing-the-data-model-)
  - [15.2.1. Install PostgreSQL #](#1521-install-postgresql-)
  - [15.2.2. Help #](#1522-help-)
  - [15.2.3. Create a database user #](#1523-create-a-database-user-)
  - [15.2.4. Verify the new account #](#1524-verify-the-new-account-)
  - [15.2.5. Create a database #](#1525-create-a-database-)
  - [15.2.6. Starting a database shell session #](#1526-starting-a-database-shell-session-)
  - [15.2.7. Make Tables in SQL #](#1527-make-tables-in-sql-)
    - [Try Yourself  #](#try-yourself--)
  - [15.2.8. Create Keys in SQL #](#1528-create-keys-in-sql-)
  - [15.2.9. Create Indexes in SQL #](#1529-create-indexes-in-sql-)
  - [15.2.10. Dropping Tables in SQL #](#15210-dropping-tables-in-sql-)
  - [15.2.11. A word on pgAdmin III #](#15211-a-word-on-pgadmin-iii-)
  - [15.2.12. In Conclusion #](#15212-in-conclusion-)
  - [15.2.13. What’s Next? #](#15213-whats-next-)
- [15.3. Lesson: Adding Data to the Model #](#153-lesson-adding-data-to-the-model-)
  - [15.3.1. Insert statement #](#1531-insert-statement-)
    - [Try Yourself  #](#try-yourself---1)
  - [15.3.2. Sequencing Data Addition According to Constraints #](#1532-sequencing-data-addition-according-to-constraints-)
  - [15.3.3. Try Yourself  #](#1533-try-yourself--)
  - [15.3.4. Select data #](#1534-select-data-)
  - [15.3.5. Update data #](#1535-update-data-)
  - [15.3.6. Delete Data #](#1536-delete-data-)
  - [15.3.7. Try Yourself  #](#1537-try-yourself--)
  - [15.3.8. In Conclusion #](#1538-in-conclusion-)
  - [15.3.9. What’s Next? #](#1539-whats-next-)
- [15.4. Lesson: Queries #](#154-lesson-queries-)
  - [15.4.1. Ordering Results #](#1541-ordering-results-)
  - [15.4.2. Filtering #](#1542-filtering-)
  - [15.4.3. Joins #](#1543-joins-)
  - [15.4.4. Sub-Select #](#1544-sub-select-)
  - [15.4.5. Aggregate Queries #](#1545-aggregate-queries-)
    - [Try Yourself  #](#try-yourself---2)
  - [15.4.6. In Conclusion #](#1546-in-conclusion-)
  - [15.4.7. What’s Next? #](#1547-whats-next-)
- [15.5. Lesson: Views #](#155-lesson-views-)
  - [15.5.1. Creating a View #](#1551-creating-a-view-)
  - [15.5.2. Modifying a View #](#1552-modifying-a-view-)
  - [15.5.3. Dropping a View #](#1553-dropping-a-view-)
  - [15.5.4. In Conclusion #](#1554-in-conclusion-)
  - [15.5.5. What’s Next? #](#1555-whats-next-)
- [15.6. Lesson: Rules #](#156-lesson-rules-)
  - [15.6.1. Creating a logging rule #](#1561-creating-a-logging-rule-)
  - [15.6.2. In Conclusion #](#1562-in-conclusion-)
  - [15.6.3. What’s Next? #](#1563-whats-next-)
- [16.1. Lesson: PostGIS Setup #](#161-lesson-postgis-setup-)
  - [16.1.1. Installing under Ubuntu #](#1611-installing-under-ubuntu-)
  - [16.1.2. Installing under Windows #](#1612-installing-under-windows-)
  - [16.1.3. Installing on Other Platforms #](#1613-installing-on-other-platforms-)
  - [16.1.4. Configuring Databases to use PostGIS #](#1614-configuring-databases-to-use-postgis-)
  - [16.1.5. Looking at the installed PostGIS functions #](#1615-looking-at-the-installed-postgis-functions-)
  - [16.1.6. Spatial Reference Systems #](#1616-spatial-reference-systems-)
  - [16.1.7. In Conclusion #](#1617-in-conclusion-)
  - [16.1.8. What’s Next? #](#1618-whats-next-)
- [16.2. Lesson: Simple Feature Model #](#162-lesson-simple-feature-model-)
  - [16.2.1. What is OGC #](#1621-what-is-ogc-)
  - [16.2.2. What is the SFS Model #](#1622-what-is-the-sfs-model-)
  - [16.2.3. Add a geometry field to table #](#1623-add-a-geometry-field-to-table-)
  - [16.2.4. Add a constraint based on geometry type #](#1624-add-a-constraint-based-on-geometry-type-)
  - [16.2.5. Try Yourself  #](#1625-try-yourself--)
  - [16.2.6. Populate geometry\_columns table #](#1626-populate-geometry_columns-table-)
    - [Try Yourself  #](#try-yourself---3)
  - [16.2.7. Add geometry record to table using SQL #](#1627-add-geometry-record-to-table-using-sql-)
    - [Try Yourself  #](#try-yourself---4)
  - [16.2.8. In Conclusion #](#1628-in-conclusion-)
  - [16.2.9. What’s Next? #](#1629-whats-next-)
- [16.3. Lesson: Import and Export #](#163-lesson-import-and-export-)
  - [16.3.1. shp2pgsql #](#1631-shp2pgsql-)
  - [16.3.2. pgsql2shp #](#1632-pgsql2shp-)
  - [16.3.3. ogr2ogr #](#1633-ogr2ogr-)
  - [16.3.4. DB Manager #](#1634-db-manager-)
  - [16.3.5. In Conclusion #](#1635-in-conclusion-)
  - [16.3.6. What’s Next? #](#1636-whats-next-)
- [16.4. Lesson: Spatial Queries #](#164-lesson-spatial-queries-)
  - [16.4.1. Spatial Operators #](#1641-spatial-operators-)
  - [16.4.2. Spatial Indexes #](#1642-spatial-indexes-)
  - [16.4.3. Try Yourself  #](#1643-try-yourself--)
  - [16.4.4. PostGIS Spatial Functions Demo #](#1644-postgis-spatial-functions-demo-)
    - [Select by location #](#select-by-location-)
    - [Select neighbors #](#select-neighbors-)
    - [Select unique values #](#select-unique-values-)
    - [Further examples … #](#further-examples--)
  - [16.4.5. In Conclusion #](#1645-in-conclusion-)
  - [16.4.6. What’s Next? #](#1646-whats-next-)

</details>

---

# 5.4. Lesson: Actions [#](#ls-actions "Permalink to this headline")

Now that you have seen a default action in the previous lesson, it is time to define your own actions.

An action is something that happens when you click on a feature. It can add a lot of extra functionality to your map, allowing you to retrieve additional information about an object, for example. Assigning actions can add a whole new dimension to your map!

**The goal for this lesson:** To learn how to add custom actions.

In this lesson you will use the school\_property layer you created previously. The sample data include photos of each of the three properties you digitized. What we are going to do is to associate each property with its image. Then we will create an action that will open the image for a property when clicking on the property.

## 5.4.1. ![basic](https://docs.qgis.org/3.28/en/_images/basic.png) Follow Along: Add a Field for Images [#](#basic-fa-add-a-field-for-images "Permalink to this headline")

The `school_property` layer has no way to associate an image with a property yet. First we will create a field for this purpose.

1.  Open the Layer Properties dialog.
    
2.  Click on the Fields tab.
    
3.  Toggle editing mode:
    
    ![https://docs.qgis.org/3.28/en/_images/toggle_editing_mode.png](https://docs.qgis.org/3.28/en/_images/toggle_editing_mode.png)
    
4.  Add a new column:
    
    ![https://docs.qgis.org/3.28/en/_images/add_new_column.png](https://docs.qgis.org/3.28/en/_images/add_new_column.png)
    
5.  Enter the values below:
    
    ![https://docs.qgis.org/3.28/en/_images/column_settings.png](https://docs.qgis.org/3.28/en/_images/column_settings.png)
    
6.  After the field has been created, move to the Attributes Form tab and select the `image` field.
    
7.  Set Widget Type to Attachment:
    
    ![https://docs.qgis.org/3.28/en/_images/select_file_name.png](https://docs.qgis.org/3.28/en/_images/select_file_name.png)
    
8.  Click OK in the Layer Properties dialog.
    
9.  Use the Identify tool to click on one of the three features in the school\_property layer.
    
    Since you are still in edit mode, the dialog should be active and look like this:
    
    ![https://docs.qgis.org/3.28/en/_images/school_property_no_image.png](https://docs.qgis.org/3.28/en/_images/school_property_no_image.png)
    
10.  Click on the browse button (the … next to the image field).
    
11.  Select the path for your image. The images are in `exercise_data/school_property_photos/` and are named the same as the features they should be associated with.
    
12.  Click OK.
    
13.  Associate all of the images with the correct features using this method.
    
14.  Save your edits and exit edit mode.
    

## 5.4.2. ![basic](https://docs.qgis.org/3.28/en/_images/basic.png) Follow Along: Creating an Action [#](#basic-fa-creating-an-action "Permalink to this headline")

1.  Open the Actions tab for the school\_property layer, and click on the [![symbologyAdd](https://docs.qgis.org/3.28/en/_images/symbologyAdd.png)](https://docs.qgis.org/3.28/en/_images/symbologyAdd.png) <sup>Add a new action</sup> button.
    
    ![https://docs.qgis.org/3.28/en/_images/layer_actions.png](https://docs.qgis.org/3.28/en/_images/layer_actions.png)
    
2.  In the Add New Action dialog, enter the words `Show Image` into the Description field:
    
    ![https://docs.qgis.org/3.28/en/_images/show_image_action.png](https://docs.qgis.org/3.28/en/_images/show_image_action.png)
    
    What to do next varies according to your operating system, so choose the appropriate course to follow:
    
    -   Windows
        
        Click on the Type dropdown and choose Open.
        
    -   Ubuntu Linux
        
        Under Action, write `eog` for the _Gnome Image Viewer_, or write `display` to use _ImageMagick_. Remember to put a space after the command!
        
    -   macOS
        
        1.  Click on the Type dropdown and choose Mac.
            
        2.  Under Action, write `open`. Remember to put a space after the command!
            
    
    Now you can continue writing the command.
    
    You want to open the image, and QGIS knows where the image is. All it needs to do is to tell the Action where the image is.
    
3.  Select image from the list:
    
    ![https://docs.qgis.org/3.28/en/_images/select_image.png](https://docs.qgis.org/3.28/en/_images/select_image.png)
    
4.  Click the Insert field button. QGIS will add the phrase `[% "image" %]` in the Action Text field.
    
5.  Click the OK button to close the Add New Action dialog
    
6.  Click OK to close the Layer Properties dialog
    

Now it is time to test the new action:

1.  Click on the school\_property layer in the Layers panel so that it is highlighted.
    
2.  Find the [![actionRun](https://docs.qgis.org/3.28/en/_images/mAction.png)](https://docs.qgis.org/3.28/en/_images/mAction.png) <sup>Run feature action</sup> button (in the Attributes Toolbar).
    
3.  Click on the down arrow to the right of this button. There is only one action defined for this layer so far, which is the one you just created.
    
    ![https://docs.qgis.org/3.28/en/_images/run_feature_action_select.png](https://docs.qgis.org/3.28/en/_images/run_feature_action_select.png)
    
4.  Click the button itself to activate the tool.
    
5.  Using this tool, click on any of the three school properties.
    
    The image for that property should open.
    

## 5.4.3. ![moderate](https://docs.qgis.org/3.28/en/_images/moderate.png) Follow Along: Searching the Internet [#](#moderate-fa-searching-the-internet "Permalink to this headline")

Let’s say we are looking at the map and want to know more about the area that a farm is in. Suppose you know nothing of the area in question and want to find general information about it. Your first impulse, considering that you’re using a computer right now, would probably be to Google the name of the area. So let’s tell QGIS to do that automatically for us!

1.  Open the attribute table for the landuse layer.
    
    We will be using the `name` field for each of our landuse areas to search Google.
    
2.  Close the attribute table.
    
3.  Go back to Actions in Layer Properties.
    
4.  Click on the Create Default Actions button to add a number of pre-defined actions.
    
5.  Remove all the actions but the Open URL action with the short name Search Web using the [![symbologyRemove](https://docs.qgis.org/3.28/en/_images/symbologyRemove.png)](https://docs.qgis.org/3.28/en/_images/symbologyRemove.png) <sup>Remove the selected action</sup> button below.
    
6.  Double-click on the remaining action to edit it
    
7.  Change the Description to `Google Search`, and remove the content of the Short Name field.
    
8.  Make sure that Canvas is among the checked Action scopes.
    
    What to do next varies according to your operating system, so choose the appropriate course to follow:
    
    -   Windows
        
        Under Type, choose Open. This will tell Windows to open an Internet address in your default browser, such as Internet Explorer.
        
    -   Ubuntu Linux
        
        Under Action, write `xdg-open`. This will tell Ubuntu to open an Internet address in your default browser, such as Chrome or Firefox.
        
    -   macOS
        
        Under Action, write `open`. This will tell macOS to open an Internet address in your default browser, such as Safari.
        
    
    Now you can continue writing the command
    
    Whichever command you used above, you need to tell it which Internet address to open next. You want it to visit Google, and to search for a phrase automatically.
    
    Usually when you use Google, you enter your search phrase into the Google Search bar. But in this case, you want your computer to do this for you. The way you tell Google to search for something (if you don’t want to use its search bar directly) is by giving your Internet browser the address `https://www.google.com/search?q=SEARCH_PHRASE`, where `` SEARCH_PHRASE` `` is what you want to search for. Since we don’t know what phrase to search for yet, we will just enter the first part (without the search phrase).
    
9.  In the Action field, write `https://www.google.com/search?q=`. Remember to add a space after your initial command before writing this in!
    
    Now you want QGIS to tell the browser to tell Google to search for the value of `name` for any feature that you could click on.
    
10.  Select the name field.
    
11.  Click Insert button:
    
    ![https://docs.qgis.org/3.28/en/_images/google_search_action.png](https://docs.qgis.org/3.28/en/_images/google_search_action.png)
    
    What this means is that QGIS is going to open the browser and send it to the address `https://www.google.com/search?q=[% "name" %]`. `[% "name" %]` tells QGIS to use the contents of the `name` field as the phrase to search for.
    
    So if, for example, the landuse area you click on is named `Marloth Nature Reserve`, QGIS is going to send the browser to `https://www.google.com/search?q=Marloth%20Nature%20Reserve`, which will cause your browser to visit Google, which will in turn search for “Marloth Nature Reserve”.
    
12.  If you have not done so already, set everything up as explained above.
    
13.  Click the OK button to close the Add New Action dialog
    
14.  Click OK to close the Layer Properties dialog
    

Now to test the new action.

1.  With the landuse layer active in the Layers panel, click on the down arrow to the right of the [![actionRun](https://docs.qgis.org/3.28/en/_images/mAction.png)](https://docs.qgis.org/3.28/en/_images/mAction.png) <sup>Run feature action</sup> button, and select the only action (`Google Search`) defined for this layer.
    
2.  Click on any landuse area you can see on the map. Your browser will now open, and will start a Google search for the place that is recorded as that area’s `name` value.
    

Note

If your action doesn’t work, check that everything was entered correctly; typos are common with this kind of work!

## 5.4.4. ![hard](https://docs.qgis.org/3.28/en/_images/hard.png) Follow Along: Open a Webpage Directly in QGIS [#](#hard-fa-open-a-webpage-directly-in-qgis "Permalink to this headline")

Above, you’ve seen how to open a webpage in an external browser. There are some shortcomings with this approach in that it adds an unknowable dependency – will the end-user have the software required to execute the action on their system? As you’ve seen, they don’t necessarily even have the same kind of base command for the same kind of action, if you don’t know which OS they will be using. With some OS versions, the above commands to open the browser might not work at all. This could be an insurmountable problem.

However, QGIS sits on top of the incredibly powerful and versatile Qt library. Also, QGIS actions can be arbitrary, tokenized (i.e. using variable information based on the contents of a field attribute) Python commands!

Now you will see how to use a python action to show a web page. It is the same general idea as opening a site in an external browser, but it requires no browser on the user’s system since it uses the Qt QWebView class (which is a webkit based html widget) to display the content in a pop-up window.

Let us use Wikipedia this time. So the URL you request will look like this:

`https://wikipedia.org/wiki/SEARCH_PHRASE`

To create the layer action:

1.  Open the Layer Properties dialog and head over to the Actions tab.
    
2.  Set up a new action using the following properties for the action:
    
    -   Type: `Python`
        
    -   Description: `Wikipedia`
        
    -   Scope: `Feature`, `Canvas`
        
    -   Action Text:
        
        ```python
        from qgis.PyQt.QtCore import QUrl
        from qgis.PyQt.QtWebKitWidgets import QWebView
        
        myWV = QWebView(None)
        myWV.load(QUrl('https://wikipedia.org/wiki/[%name%]'))
        myWV.show()
        
        ```
        
        Copy to clipboard
        
    
    ![https://docs.qgis.org/3.28/en/_images/python_action_example.png](https://docs.qgis.org/3.28/en/_images/python_action_example.png)
    
    There are a couple of things going on here:
    
    -   `[%name%]` will be replaced by the actual attribute value when the action is invoked (as before).
        
    -   The code simply creates a new `QWebView` instance, sets its URL, and then calls `show()` on it to make it visible as a window on the user’s desktop.
        
    
    You could also use this approach to display an image without requiring that the users have a particular image viewer on their system.
    
3.  Try to use the methods described above to load a Wikipedia page using the Wikipedia action you just created.
    

## 5.4.5. In Conclusion [#](#ic "Permalink to this headline")

Actions allow you to give your map extra functionality, useful to the end-user who views the same map in QGIS. Due to the fact that you can use shell commands for any operating system, as well as Python, the sky is the limit in terms of the functions you could incorporate!

## 5.4.6. What’s Next? [#](#wn "Permalink to this headline")

Now that you’ve done all kinds of vector data creation, you will learn how to analyze the data to solve problems. That is the topic of the next module.

---

# 6.3. Lesson: Network Analysis [#](https://docs.qgis.org/3.28/en/docs/training_manual/vector_analysis/network_analysis.html#ls-network-analysis "Permalink to this headline")

Calculating the shortest distance between two points is a common GIS task. Tools for this can be found in the Processing Toolbox.

**The goal for this lesson:** learn to use Network analysis algorithms.

## 6.3.1. ![basic](https://docs.qgis.org/3.28/en/_images/basic.png) Follow Along: The Tools and the Data [#](https://docs.qgis.org/3.28/en/docs/training_manual/vector_analysis/network_analysis.html#basic-fa-the-tools-and-the-data "Permalink to this headline")

You can find all the network analysis algorithms in the Processing ► Network Analysis menu. You can see that there are many tools available:

[![../../../_images/select_network_algorithms.png](https://docs.qgis.org/3.28/en/_images/select_network_algorithms.png)](https://docs.qgis.org/3.28/en/_images/select_network_algorithms.png)

Open the project `exercise_data/network_analysis/network.qgz`. It contains two layers:

-   `network_points`
    
-   `network_lines`
    

The network\_lines layer has already a style that helps to understand the road network.

[![../../../_images/network_map.png](https://docs.qgis.org/3.28/en/_images/network_map.png)](https://docs.qgis.org/3.28/en/_images/network_map.png)

The shortest path tools provide ways to calculate either the shortest or the fastest path between two points of a network, given:

-   start and end points selected on the map
    
-   start point selected on the map and end points taken from a point layer
    
-   start points taken from a point layer and end point selected on the map
    

Let’s start.

## 6.3.2. ![basic](https://docs.qgis.org/3.28/en/_images/basic.png) Calculate the shortest path (point to point) [#](https://docs.qgis.org/3.28/en/docs/training_manual/vector_analysis/network_analysis.html#basic-calculate-the-shortest-path-point-to-point "Permalink to this headline")

The Network analysis ► Shortest path (point to point) allows you to calculate the shortest distance between two manually selected points on the map.

In this example we will calculate the **shortest** (not fastest) path between two points.

1.  Open the Shortest path (point to point) algorithm
    
2.  Select network\_lines for Vector layer representing network
    
3.  Use `Shortest` for Path type to calculate
    
    Use these two points as starting and ending points for the analysis:
    
    [![../../../_images/start_end_point.png](https://docs.qgis.org/3.28/en/_images/start_end_point.png)](https://docs.qgis.org/3.28/en/_images/start_end_point.png)
    
4.  Click on the … button next to Start point (x, y) and choose the location tagged with `Starting Point` in the picture. Enable the snapping options for an accurate selection. The coordinates of the clicked point are added.
    
5.  Do the same thing, but choosing the location tagged with `Ending point` for End point (x, y)
    
6.  Click on the Run button:
    
    [![../../../_images/shortest_point.png](https://docs.qgis.org/3.28/en/_images/shortest_point.png)](https://docs.qgis.org/3.28/en/_images/shortest_point.png)
    
7.  A new line layer is created representing the shortest path between the chosen points. Uncheck the `network_lines` layer to see the result better:
    
    [![../../../_images/shortest_point_result.png](https://docs.qgis.org/3.28/en/_images/shortest_point_result.png)](https://docs.qgis.org/3.28/en/_images/shortest_point_result.png)
    
8.  Open the attribute table of the output layer. It contains three fields, representing the coordinates of the start and end points and the **cost**.
    
    We chose `Shortest` as Path type to calculate, so the **cost** represent the **distance**, in layer units, between the two locations.
    
    In our case, the _shortest_ distance between the chosen points is around `1000` meters:
    
    [![../../../_images/shortest_point_attributes.png](https://docs.qgis.org/3.28/en/_images/shortest_point_attributes.png)](https://docs.qgis.org/3.28/en/_images/shortest_point_attributes.png)
    

Now that you know how to use the tool, feel free to test other locations.

## 6.3.3. ![moderate](https://docs.qgis.org/3.28/en/_images/moderate.png) Try Yourself Fastest path [#](https://docs.qgis.org/3.28/en/docs/training_manual/vector_analysis/network_analysis.html#moderate-ty-fastest-path "Permalink to this headline")

With the same data of the previous exercise, try to calculate the fastest path between the two points.

How much time do you need to go from the start to the end point?

Answer

1.  Open Network Analysis ► Shortest Path (Point to Point) and fill the dialog as:
    
    ![../../../_images/fastest_path_result.png](https://docs.qgis.org/3.28/en/_images/fastest_path_result.png)
    
2.  Make sure that the Path type to calculate is `Fastest`.
    
3.  Click on Run and close the dialog.
    
4.  Open now the attribute table of the output layer. The cost field contains the travel time between the two points (as fraction of hours):
    
    ![../../../_images/fastest_path_attribute.png](https://docs.qgis.org/3.28/en/_images/fastest_path_attribute.png)
    

## 6.3.4. ![moderate](https://docs.qgis.org/3.28/en/_images/moderate.png) Follow Along: Advanced options [#](https://docs.qgis.org/3.28/en/docs/training_manual/vector_analysis/network_analysis.html#moderate-fa-advanced-options "Permalink to this headline")

Let us explore some more options of the Network Analysis tools. In the [previous exercise](https://docs.qgis.org/3.28/en/docs/training_manual/vector_analysis/network_analysis.html#network-fastest-path) we calculated the **fastest** route between two points. As you can imagine, the time depends on the travel **speed**.

We will use the same layers and starting and ending points of the previous exercises.

1.  Open the Shortest path (point to point) algorithm
    
2.  Fill the Input layer, Start point (x, y) and End point (x, y) as we did before
    
3.  Choose `Fastest` as the Path type to calculate
    
4.  Open the Advanced parameter menu
    
5.  Change the Default speed (km/h) from the default `50` value to `4`
    
    [![../../../_images/shortest_path_advanced.png](https://docs.qgis.org/3.28/en/_images/shortest_path_advanced.png)](https://docs.qgis.org/3.28/en/_images/shortest_path_advanced.png)
    
6.  Click on Run
    
7.  Once the algorithm is finished, close the dialog and open the attribute table of the output layer.
    
    The _cost_ field contains the value according to the speed parameter you have chosen. We can convert the _cost_ field from hours with fractions to the more readable _minutes_ values.
    
8.  Open the field calculator by clicking on the [![calculateField](https://docs.qgis.org/3.28/en/_images/mActionCalculateField.png)](https://docs.qgis.org/3.28/en/_images/mActionCalculateField.png) icon
    
9.  Add a new field to store the path cost in minutes.
    
    [![../../../_images/shortest_path_conversion.png](https://docs.qgis.org/3.28/en/_images/shortest_path_conversion.png)](https://docs.qgis.org/3.28/en/_images/shortest_path_conversion.png)
    

That’s it! Now you know how many minutes it will take to get from one point to the other one if the whole network speed is at `4 km/h`.

## 6.3.5. ![hard](https://docs.qgis.org/3.28/en/_images/hard.png) Shortest path with speed limit [#](https://docs.qgis.org/3.28/en/docs/training_manual/vector_analysis/network_analysis.html#hard-shortest-path-with-speed-limit "Permalink to this headline")

The Network analysis toolbox has other interesting options. Looking at the following map:

[![../../../_images/speed_limit.png](https://docs.qgis.org/3.28/en/_images/speed_limit.png)](https://docs.qgis.org/3.28/en/_images/speed_limit.png)

we would like to know the **fastest** route considering the **speed limits** of each road (the labels represent the speed limits in km/h). The shortest path without considering speed limits would of course be the purple path. But in that road the speed limit is 20 km/h, while in the green road you can go at 100 km/h!

As we did in the first exercise, we will use the Network analysis ► Shortest path (point to point) and we will manually choose the start and end points.

1.  Open the Network analysis ► Shortest path (point to point) algorithm
    
2.  Select network\_lines for the Vector layer representing network parameter
    
3.  Choose `Fastest` as the Path type to calculate
    
4.  Select the Start point (x, y) and End point (x, y) as we did before
    
5.  Open the Advanced parameters menu
    
6.  Choose the _speed_ field as the Speed Field parameter. With this option the algorithm will take into account the speed limits for each road.
    
    [![../../../_images/speed_limit_parameters.png](https://docs.qgis.org/3.28/en/_images/speed_limit_parameters.png)](https://docs.qgis.org/3.28/en/_images/speed_limit_parameters.png)
    
7.  Click on the Run button
    
8.  Turn off the `network_lines` layer to better see the result
    
    [![../../../_images/speed_limit_result.png](https://docs.qgis.org/3.28/en/_images/speed_limit_result.png)](https://docs.qgis.org/3.28/en/_images/speed_limit_result.png)
    

As you can see the fastest route does not correspond to the shortest one.

## 6.3.6. ![moderate](https://docs.qgis.org/3.28/en/_images/moderate.png) Service area (from layer) [#](https://docs.qgis.org/3.28/en/docs/training_manual/vector_analysis/network_analysis.html#moderate-service-area-from-layer "Permalink to this headline")

The Network Analysis ► Service area (from layer) algorithm can answer the question: given a point layer, what are all the reachable areas given a distance or a time value?

Note

The Network Analysis ► Service area (from point) is the same algorithm, but it allows you to manually choose the point on the map.

Given a distance of `250` meters we want to know how far we can go on the network from each point of the network\_points layer.

1.  Uncheck all the layers except `network_points`
    
2.  Open the Network Analysis ► Service area (from layer) algorithm
    
3.  Choose `network_lines` for Vector layer representing network
    
4.  Choose `network_points` for Vector layer with start points
    
5.  Choose `Shortest` in Path type to calculate
    
6.  Enter `250` for the Travel cost parameter
    
7.  Click on Run and close the dialog
    
    [![../../../_images/service_area.png](https://docs.qgis.org/3.28/en/_images/service_area.png)](https://docs.qgis.org/3.28/en/_images/service_area.png)
    
    The output layer represents the maximum path you can reach from the point features given a distance of 250 meters:
    
    [![../../../_images/service_area_result.png](https://docs.qgis.org/3.28/en/_images/service_area_result.png)](https://docs.qgis.org/3.28/en/_images/service_area_result.png)
    

Cool isn’t it?

## 6.3.7. In Conclusion [#](https://docs.qgis.org/3.28/en/docs/training_manual/vector_analysis/network_analysis.html#ic "Permalink to this headline")

Now you know how to use Network analysis algorithm to solve shortest and fastest path problems.

We are now ready to perform some spatial statistic on vector layer data. Let’s go!

## 6.3.8. What’s Next? [#](https://docs.qgis.org/3.28/en/docs/training_manual/vector_analysis/network_analysis.html#wn "Permalink to this headline")

Next you’ll see how to run spatial statistics algorithms on vector datasets.

---

# 11.1. Lesson: Install QGIS Server [#](https://docs.qgis.org/3.28/en/docs/training_manual/qgis_server/install.html#ls-install-qgis-server "Permalink to this headline")

**The goal for this lesson:** To learn how to install **QGIS Server** on Debian Stretch. With negligible variations you can also follow it for any Debian based distribution like Ubuntu and its derivatives.

Note

In Ubuntu you can use your regular user, prepending `sudo` to commands requiring admin permissions. In Debian you can work as admin (`root`), without using `sudo`.

## 11.1.1. ![moderate](https://docs.qgis.org/3.28/en/_images/moderate.png) Follow Along: Install from packages [#](https://docs.qgis.org/3.28/en/docs/training_manual/qgis_server/install.html#moderate-fa-install-from-packages "Permalink to this headline")

In this lesson we’re going to do only the install from packages as shown [here](https://qgis.org/en/site/forusers/alldownloads.html#linux) .

Install QGIS Server with:

```
apt install qgis-server --no-install-recommends --no-install-suggests

# if you want to install server plugins, also:
apt install python3-qgis

```

Copy to clipboard

QGIS Server should be used in production without QGIS Desktop (with the accompanying X Server) installed on the same machine.

## 11.1.2. ![moderate](https://docs.qgis.org/3.28/en/_images/moderate.png) Follow Along: QGIS Server Executable [#](https://docs.qgis.org/3.28/en/docs/training_manual/qgis_server/install.html#moderate-fa-qgis-server-executable "Permalink to this headline")

The QGIS Server executable is `qgis_mapserv.fcgi`. You can check where it has been installed by running `find / -name 'qgis_mapserv.fcgi'` which should output something like `/usr/lib/cgi-bin/qgis_mapserv.fcgi`.

Optionally, if you want to do a command line test at this time you can run the `/usr/lib/cgi-bin/qgis_mapserv.fcgi --version` command which should output something like:

```
QGIS 3.21.0-Master 'Master' (1c70953f1e)
QGIS code revision 1c70953f1e
Qt version 5.15.2
Python version 3.9.5
GDAL/OGR version 3.2.2
PROJ version 7.2.1
EPSG Registry database version v10.008 (2020-12-16)
GEOS version 3.9.0-CAPI-1.16.2
SQLite version 3.34.1
OS Ubuntu 21.04

```

Copy to clipboard

We’ll see later on how to make WMS requests.

## 11.1.3. ![hard](https://docs.qgis.org/3.28/en/_images/hard.png) HTTP Server Configuration [#](https://docs.qgis.org/3.28/en/docs/training_manual/qgis_server/install.html#hard-http-server-configuration "Permalink to this headline")

In order to access on the installed QGIS server from an Internet Browser we need to use an HTTP server. The Apache HTTP Server installation process is detailed in [Apache HTTP Server](https://docs.qgis.org/3.28/en/docs/training_manual/qgis_server/install.html../../server_manual/getting_started.html#httpserver) section.

Note

If you installed QGIS Server without running an X Server (included in Linux Desktop) and if you also want to use the `GetPrint` command then you should install a fake X Server and tell QGIS Server to use it. You can do that by following the [Xvfb installation process](https://docs.qgis.org/3.28/en/docs/training_manual/qgis_server/install.html../../server_manual/getting_started.html#xvfb).

## 11.1.4. ![moderate](https://docs.qgis.org/3.28/en/_images/moderate.png) Follow Along: Create another virtual host [#](https://docs.qgis.org/3.28/en/docs/training_manual/qgis_server/install.html#moderate-fa-create-another-virtual-host "Permalink to this headline")

Let’s create another Apache virtual host pointing to QGIS Server. You can choose whatever name you like (`coco.bango`, `super.duper.training`, `example.com`, etc.) but for simplicity sake we’re going to use `myhost`.

-   Let’s set up the `myhost` name to point to the localhost IP by adding `127.0.0.1 x` to the `/etc/hosts` with the following command: `sh -c "echo '127.0.0.1 myhost' >> /etc/hosts"` or by manually editing the file with `gedit /etc/hosts`.
    
-   We can check that `myhost` points to the localhost by running in the terminal the `ping myhost` command which should output:
    

```
qgis@qgis:~$ ping myhost
PING myhost (127.0.0.1) 56(84) bytes of data.
64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.024 ms
64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.029 ms

```

Copy to clipboard

-   Let’s try if we can access QGIS Server from the `myhost` site by doing: `curl http://myhost/cgi-bin/qgis_mapserv.fcgi` or by accessing the url from your Debian box browser. You will probably get:
    

```
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>404 Not Found</title>
</head><body>
<h1>Not Found</h1>
<p>The requested URL /cgi-bin/qgis_mapserv.fcgi was not found on this server.</p>
<hr>
<address>Apache/2.4.25 (Debian) Server at myhost Port 80</address>
</body></html>

```

Copy to clipboard

-   Apache doesn’t know that he’s supposed to answer requests pointing to the server named `myhost`. In order to setup the virtual host the simplest way would be to make a `myhost.conf` file in the `/etc/apache2/sites-available` directory that has the same content as `qgis.demo.conf` except for the `ServerName` line that should be `ServerName myhost`. You could also change where the logs go as otherwise the logs for the two virtual hosts would be shared but this is optional.
    
-   Let’s now enable the virtual host with `a2ensite myhost.conf` and then reload the Apache service with `service apache2 reload`.
    
-   If you try again to access the [http://myhost/cgi-bin/qgis\_mapserv.fcgi](http://myhost/cgi-bin/qgis_mapserv.fcgi) url you’ll notice everything is working now!
    

## 11.1.5. In Conclusion [#](https://docs.qgis.org/3.28/en/docs/training_manual/qgis_server/install.html#ic "Permalink to this headline")

You learned how to install different QGIS Server versions from packages, how to configure Apache with QGIS Server, on Debian based Linux distros.

## 11.1.6. What’s Next? [#](https://docs.qgis.org/3.28/en/docs/training_manual/qgis_server/install.html#wn "Permalink to this headline")

Now that you’ve installed QGIS Server and it’s accessible through the HTTP protocol, we need to learn how to access some of the services it can offer. The topic of the next lesson is to learn how to access QGIS Server WMS services.

---

15.1. Lesson: Introduction to Databases #
Before using PostgreSQL, let’s make sure of our ground by covering general database theory. You will not need to enter any of the example code; it’s only there for illustration purposes.

The goal for this lesson: To understand fundamental database concepts.

15.1.1. What is a Database? #
A database consists of an organized collection of data for one or more uses, typically in digital form. - Wikipedia

A database management system (DBMS) consists of software that operates databases, providing storage, access, security, backup and other facilities. - Wikipedia

15.1.2. Tables #
In relational databases and flat file databases, a table is a set of data elements (values) that is organized using a model of vertical columns (which are identified by their name) and horizontal rows. A table has a specified number of columns, but can have any number of rows. Each row is identified by the values appearing in a particular column subset which has been identified as a candidate key. - Wikipedia

 id | name  | age
----+-------+-----
  1 | Tim   |  20
  2 | Horst |  88
(2 rows)
In SQL databases a table is also known as a relation.

15.1.3. Columns / Fields #
A column is a set of data values of a particular simple type, one for each row of the table. The columns provide the structure according to which the rows are composed. The term field is often used interchangeably with column, although many consider it more correct to use field (or field value) to refer specifically to the single item that exists at the intersection between one row and one column. - Wikipedia

A column:

| name  |
+-------+
| Tim   |
| Horst |
A field:

| Horst |
15.1.4. Records #
A record is the information stored in a table row. Each record will have a field for each of the columns in the table.

2 | Horst |  88  <-- one record
15.1.5. Datatypes #
Datatypes restrict the kind of information that can be stored in a column. - Tim and Horst

There are many kinds of datatypes. Let’s focus on the most common:

String - to store free-form text data

Integer - to store whole numbers

Real - to store decimal numbers

Date - to store Horst’s birthday so no one forgets

Boolean - to store simple true/false values

You can tell the database to allow you to also store nothing in a field. If there is nothing in a field, then the field content is referred to as a ‘null’ value:

insert into person (age) values (40);

select * from person;
Result:

id | name  | age
---+-------+-----
 1 | Tim   |  20
 2 | Horst |  88
 4 |       |  40  <-- null for name
(3 rows)
There are many more datatypes you can use - check the PostgreSQL manual!

15.1.6. Modelling an Address Database #
Let’s use a simple case study to see how a database is constructed. We want to create an address database.

Try Yourself basic #
Write down the properties which make up a simple address and which we would want to store in our database.

Answer 



Address Structure #
The properties that describe an address are the columns. The type of information stored in each column is its datatype. In the next section we will analyse our conceptual address table to see how we can make it better!

15.1.7. Database Theory #
The process of creating a database involves creating a model of the real world; taking real world concepts and representing them in the database as entities.

15.1.8. Normalisation #
One of the main ideas in a database is to avoid data duplication / redundancy. The process of removing redundancy from a database is called Normalisation.

Normalization is a systematic way of ensuring that a database structure is suitable for general-purpose querying and free of certain undesirable characteristics - insertion, update, and deletion anomalies - that could lead to a loss of data integrity. - Wikipedia

There are different kinds of normalisation ‘forms’.

Let’s take a look at a simple example:

Table "public.people"

Column    |          Type          |                Modifiers
----------+------------------------+------------------------------------
 id       | integer                | not null default
          |                        | nextval('people_id_seq'::regclass)
          |                        |
 name     | character varying(50)  |
 address  | character varying(200) | not null
 phone_no | character varying      |
Indexes:
 "people_pkey" PRIMARY KEY, btree (id)
select * from people;

id |     name      |           address           |  phone_no
---+---------------+-----------------------------+-------------
 1 | Tim Sutton    | 3 Buirski Plein, Swellendam | 071 123 123
 2 | Horst Duester | 4 Avenue du Roix, Geneva    | 072 121 122
(2 rows)
Imagine you have many friends with the same street name or city. Every time this data is duplicated, it consumes space. Worse still, if a city name changes, you have to do a lot of work to update your database.

15.1.9. Try Yourself basic #
Redesign the theoretical people table above to reduce duplication and to normalise the data structure.

You can read more about database normalisation here

Answer 



15.1.10. Indexes #
A database index is a data structure that improves the speed of data retrieval operations on a database table. - Wikipedia

Imagine you are reading a textbook and looking for the explanation of a concept - and the textbook has no index! You will have to start reading at one cover and work your way through the entire book until you find the information you need. The index at the back of a book helps you to jump quickly to the page with the relevant information:

create index person_name_idx on people (name);
Now searches on name will be faster:

Table "public.people"

Column   |          Type          |               Modifiers
----------+------------------------+-------------------------------------
 id       | integer                | not null default
          |                        | nextval('people_id_seq'::regclass)
          |                        |
 name     | character varying(50)  |
 address  | character varying(200) | not null
 phone_no | character varying      |
Indexes:
 "people_pkey" PRIMARY KEY, btree (id)
 "person_name_idx" btree (name)
15.1.11. Sequences #
A sequence is a unique number generator. It is normally used to create a unique identifier for a column in a table.

In this example, id is a sequence - the number is incremented each time a record is added to the table:

id |     name     |           address           |  phone_no
---+--------------+-----------------------------+-------------
 1 | Tim Sutton   | 3 Buirski Plein, Swellendam | 071 123 123
 2 | Horst Duster | 4 Avenue du Roix, Geneva    | 072 121 122
15.1.12. Entity Relationship Diagramming #
In a normalised database, you typically have many relations (tables). The entity-relationship diagram (ER Diagram) is used to design the logical dependencies between the relations. Consider our non-normalised people table from earlier in the lesson:

select * from people;

 id |     name     |           address           |  phone_no
----+--------------+-----------------------------+-------------
 1  | Tim Sutton   | 3 Buirski Plein, Swellendam | 071 123 123
 2  | Horst Duster | 4 Avenue du Roix, Geneva    | 072 121 122
(2 rows)
With a little work we can split it into two tables, removing the need to repeat the street name for individuals who live in the same street:

select * from streets;

 id |     name
----+--------------
 1  | Plein Street
(1 row)
and:

select * from people;

 id |     name     | house_no | street_id |  phone_no
----+--------------+----------+-----------+-------------
  1 | Horst Duster |        4 |         1 | 072 121 122
(1 row)
We can then link the two tables using the ‘keys’ streets.id and people.streets_id.

If we draw an ER Diagram for these two tables it would look something like this:

../../../_images/er-people-streets.png
The ER Diagram helps us to express ‘one to many’ relationships. In this case the arrow symbol show that one street can have many people living on it.

Try Yourself moderate #
Our people model still has some normalisation issues - try to see if you can normalise it further and show your thoughts by means of an ER Diagram.

Answer 






15.1.13. Constraints, Primary Keys and Foreign Keys #
A database constraint is used to ensure that data in a relation matches the modeller’s view of how that data should be stored. For example a constraint on your postal code could ensure that the number falls between 1000 and 9999.

A Primary key is one or more field values that make a record unique. Usually the primary key is called id and is a sequence.

A Foreign key is used to refer to a unique record on another table (using that other table’s primary key).

In ER Diagramming, the linkage between tables is normally based on Foreign keys linking to Primary keys.

If we look at our people example, the table definition shows that the street column is a foreign key that references the primary key on the streets table:

Table "public.people"

 Column    |         Type          |  Modifiers
-----------+-----------------------+--------------------------------------
 id        | integer               | not null default
           |                       | nextval('people_id_seq'::regclass)
 name      | character varying(50) |
 house_no  | integer               | not null
 street_id | integer               | not null
 phone_no  | character varying     |
Indexes:
"people_pkey" PRIMARY KEY, btree (id)
Foreign-key constraints:
"people_street_id_fkey" FOREIGN KEY (street_id) REFERENCES streets(id)
15.1.14. Transactions #
When adding, changing, or deleting data in a database, it is always important that the database is left in a good state if something goes wrong. Most databases provide a feature called transaction support. Transactions allow you to create a rollback position that you can return to if your modifications to the database did not run as planned.

Take a scenario where you have an accounting system. You need to transfer funds from one account and add them to another. The sequence of steps would go like this:

remove R20 from Joe

add R20 to Anne

If something goes wrong during the process (e.g. power failure), the transaction will be rolled back.

15.1.15. In Conclusion #
Databases allow you to manage data in a structured way using simple code structures.

15.1.16. What’s Next? #
Now that we’ve looked at how databases work in theory, let’s create a new database to implement the theory

---

# 15.2. Lesson: Implementing the Data Model [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/data_model.html#ls-implementing-the-data-model "Permalink to this headline")

Now that we’ve covered all the theory, let’s create a new database. This database will be used for our exercises for the lessons that will follow afterwards.

**The goal for this lesson:** To install the required software and use it to implement our example database.

## 15.2.1. Install PostgreSQL [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/data_model.html#install-postgresql "Permalink to this headline")

Note

You can find PostgreSQL packages and installation instructions for your operating system at [https://www.postgresql.org/download/](https://www.postgresql.org/download/). Please note that the documentation will assume users are running QGIS under Ubuntu.

Under Ubuntu:

```
sudo apt install postgresql-9.1

```

Copy to clipboard

You should get a message like this:

```
[sudo] password for qgis:
Reading package lists... Done
Building dependency tree
Reading state information... Done
The following extra packages will be installed:
postgresql-client-9.1 postgresql-client-common postgresql-common
Suggested packages:
oidentd ident-server postgresql-doc-9.1
The following NEW packages will be installed:
postgresql-9.1 postgresql-client-9.1 postgresql-client-common postgresql-common
0 upgraded, 4 newly installed, 0 to remove and 5 not upgraded.
Need to get 5,012kB of archives.
After this operation, 19.0MB of additional disk space will be used.
Do you want to continue [Y/n]?

```

Copy to clipboard

Press Y and Enter and wait for the download and installation to finish.

## 15.2.2. Help [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/data_model.html#help "Permalink to this headline")

PostgreSQL has very good [online](https://www.postgresql.org/docs/9.1/index.html) documentation.

## 15.2.3. Create a database user [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/data_model.html#create-a-database-user "Permalink to this headline")

Under Ubuntu:

After the installation is complete, run this command to become the postgres user and then create a new database user:

```
sudo su - postgres

```

Copy to clipboard

Type in your normal log in password when prompted (you need to have sudo rights).

Now, at the postgres user’s bash prompt, create the database user. Make sure the user name matches your unix login name: it will make your life much easier, as postgres will automatically authenticate you when you are logged in as that user:

```
createuser -d -E -i -l -P -r -s qgis

```

Copy to clipboard

Enter a password when prompted. You should use a different password to your login password.

What do those options mean?

```
-d, --createdb     role can create new databases
-E, --encrypted    encrypt stored password
-i, --inherit      role inherits privileges of roles it is a member of (default)
-l, --login        role can login (default)
-P, --pwprompt     assign a password to new role
-r, --createrole   role can create new roles
-s, --superuser    role will be superuser

```

Copy to clipboard

Now you should leave the postgres user’s bash shell environment by typing:

```
exit

```

Copy to clipboard

## 15.2.4. Verify the new account [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/data_model.html#verify-the-new-account "Permalink to this headline")

```
psql -l

```

Copy to clipboard

Should return something like this:

```
Name      |  Owner   | Encoding | Collation  |   Ctype    |
----------+----------+----------+------------+------------+
postgres  | postgres | UTF8     | en_ZA.utf8 | en_ZA.utf8 |
template0 | postgres | UTF8     | en_ZA.utf8 | en_ZA.utf8 |
template1 | postgres | UTF8     | en_ZA.utf8 | en_ZA.utf8 |
(3 rows)

```

Copy to clipboard

Type Q to exit.

## 15.2.5. Create a database [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/data_model.html#create-a-database "Permalink to this headline")

The `createdb` command is used to create a new database. It should be run from the bash shell prompt:

```
createdb address -O qgis

```

Copy to clipboard

You can verify the existence of your new database by using this command:

```
psql -l

```

Copy to clipboard

Which should return something like this:

```
Name      |  Owner   | Encoding | Collation  |   Ctype    |   Access privileges
----------+----------+----------+------------+------------+-----------------------
address   | qgis     | UTF8     | en_ZA.utf8 | en_ZA.utf8 |
postgres  | postgres | UTF8     | en_ZA.utf8 | en_ZA.utf8 |
template0 | postgres | UTF8     | en_ZA.utf8 | en_ZA.utf8 | =c/postgres: postgres=CTc/postgres
template1 | postgres | UTF8     | en_ZA.utf8 | en_ZA.utf8 | =c/postgres: postgres=CTc/postgres
(4 rows)

```

Copy to clipboard

Type Q to exit.

## 15.2.6. Starting a database shell session [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/data_model.html#starting-a-database-shell-session "Permalink to this headline")

You can connect to your database easily like this:

```
psql address

```

Copy to clipboard

To exit out of the psql database shell, type:

```
\q

```

Copy to clipboard

For help in using the shell, type:

```
\?

```

Copy to clipboard

For help in using sql commands, type:

```
\help

```

Copy to clipboard

To get help on a specific command, type (for example):

```
\help create table

```

Copy to clipboard

See also the [Psql cheat sheet](http://www.postgresonline.com/downloads/special_feature/postgresql90_cheatsheet_A4.pdf).

## 15.2.7. Make Tables in SQL [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/data_model.html#make-tables-in-sql "Permalink to this headline")

Let’s start making some tables! We will use our ER Diagram as a guide. First, connect to the address db:

```
psql address

```

Copy to clipboard

Then create a `streets` table:

```
create table streets (id serial not null primary key, name varchar(50));

```

Copy to clipboard

serial and varchar are **data types**. serial tells PostgreSQL to start an integer sequence (auto-number) to populate the id automatically for every new record. varchar(50) tells PostgreSQL to create a character field of 50 characters in length.

You will notice that the command ends with a ; - all SQL commands should be terminated this way. When you press Enter, psql will report something like this:

```
NOTICE:  CREATE TABLE will create implicit sequence "streets_id_seq"
         for serial column "streets.id"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index
         "streets_pkey" for table "streets"
CREATE TABLE

```

Copy to clipboard

That means your table was created successfully, with a primary key streets\_pkey using streets.id.

Note: If you hit return without entering a ;, then you will get a prompt like this: address\-#. This is because PG is expecting you to enter more. Enter ; to run your command.

To view your table schema, you can do this:

```
\d streets

```

Copy to clipboard

Which should show something like this:

```
Table "public.streets"
Column  |         Type          |            Modifiers
--------+-----------------------+--------------------------------------
 id     | integer               | not null default
        |                       | nextval('streets_id_seq'::regclass)
 name   | character varying(50) |
Indexes:
  "streets_pkey" PRIMARY KEY, btree (id)

```

Copy to clipboard

To view your table contents, you can do this:

```
select * from streets;

```

Copy to clipboard

Which should show something like this:

```
id | name
---+------
(0 rows)

```

Copy to clipboard

As you can see, our table is currently empty.

### Try Yourself ![moderate](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/data_model.html../../../_images/moderate.png) [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/data_model.html#ty-moderate "Permalink to this headline")

Use the approach shown above to make a table called people:

Add fields such as phone number, home address, name, etc. (these aren’t all valid names: change them to make them valid). Make sure you give the table an ID column with the same data-type as above.

Answer

The SQL required to create the correct people table is:

```
create table people (id serial not null primary key,
                     name varchar(50),
                     house_no int not null,
                     street_id int not null,
                     phone_no varchar null );

```

Copy to clipboard

The schema for the table (enter `\\d people`) looks like this:

```
Table "public.people"

Column     |         Type          |                      Modifiers
-----------+-----------------------+-------------------------------------
id         | integer               | not null default
           |                       | nextval('people_id_seq'::regclass)
name       | character varying(50) |
house_no   | integer               | not null
street_id  | integer               | not null
phone_no   | character varying     |
Indexes:
  "people_pkey" PRIMARY KEY, btree (id)

```

Copy to clipboard

For illustration purposes, we have purposely omitted the fkey constraint.

## 15.2.8. Create Keys in SQL [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/data_model.html#create-keys-in-sql "Permalink to this headline")

The problem with our solution above is that the database doesn’t know that people and streets have a logical relationship. To express this relationship, we have to define a foreign key that points to the primary key of the streets table.

![../../../_images/er-people-streets.png](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/data_model.html../../../_images/er-people-streets.png)

There are two ways to do this:

-   Add the key after the table has been created
    
-   Define the key at time of table creation
    

Our table has already been created, so let’s do it the first way:

```
alter table people
  add constraint people_streets_fk foreign key (street_id) references streets(id);

```

Copy to clipboard

That tells the people table that its street\_id fields must match a valid street id from the streets table.

The more usual way to create a constraint is to do it when you create the table:

```
create table people (id serial not null primary key,
                     name varchar(50),
                     house_no int not null,
                     street_id int references streets(id) not null,
                     phone_no varchar null);

\d people

```

Copy to clipboard

After adding the constraint, our table schema looks like this now:

```
Table "public.people"

  Column   |         Type          |            Modifiers
-----------+-----------------------+---------------------------------
 id        | integer               | not null default
           |                       | nextval('people_id_seq'::regclass)
 name      | character varying(50) |
 house_no  | integer               | not null
 street_id | integer               | not null
 phone_no  | character varying     |
Indexes:
  "people_pkey" PRIMARY KEY, btree (id)
Foreign-key constraints:
  "people_streets_fk" FOREIGN KEY (id) REFERENCES streets(id)

```

Copy to clipboard

## 15.2.9. Create Indexes in SQL [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/data_model.html#create-indexes-in-sql "Permalink to this headline")

We want lightning fast searches on peoples names. To provide for this, we can create an index on the name column of our people table:

```
create index people_name_idx on people(name);

\d people

```

Copy to clipboard

Which results in:

```
Table "public.people"

  Column   |         Type          |                      Modifiers
-----------+-----------------------+-----------------------------------
 id        | integer               | not null default nextval
           |                       | ('people_id_seq'::regclass)
 name      | character varying(50) |
 house_no  | integer               | not null
 street_id | integer               | not null
 phone_no  | character varying     |
Indexes:
 "people_pkey" PRIMARY KEY, btree (id)
 "people_name_idx" btree (name)    <-- new index added!
Foreign-key constraints:
 "people_streets_fk" FOREIGN KEY (id) REFERENCES streets(id)

```

Copy to clipboard

## 15.2.10. Dropping Tables in SQL [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/data_model.html#dropping-tables-in-sql "Permalink to this headline")

If you want to get rid of a table you can use the drop command:

```
drop table streets;

```

Copy to clipboard

In our current example, the above command would not work. Why not?

Answer

The reason the DROP command would not work in this case is because the _people_ table has a Foreign Key constraint to the _streets_ table. This means that dropping (or deleting) the _streets_ table would leave the _people_ table with references to non-existent _streets_ data.

It is possible to ‘force’ the _streets_ table to be deleted by using the `CASCADE` command, but this would also delete the _people_ and any other table which had a relationship to the _streets_ table. Use with caution!

If you used the same drop table command on the people table, it would be successful:

```
drop table people;

```

Copy to clipboard

Note

If you actually did enter that command and dropped the people table, now would be a good time to rebuild it, as you will need it in the next exercises.

## 15.2.11. A word on pgAdmin III [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/data_model.html#a-word-on-pgadmin-iii "Permalink to this headline")

We are showing you the SQL commands from the psql prompt because it’s a very useful way to learn about databases. However, there are quicker and easier ways to do a lot of what we are showing you. Install pgAdmin III and you can create, drop, alter etc tables using ‘point and click’ operations in a GUI.

Under Ubuntu, you can install it like this:

```
sudo apt install pgadmin3

```

Copy to clipboard

pgAdmin III will be covered in more detail in another module.

## 15.2.12. In Conclusion [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/data_model.html#ic "Permalink to this headline")

You have now seen how to create a brand new database, starting completely from scratch.

## 15.2.13. What’s Next? [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/data_model.html#wn "Permalink to this headline")

Next you’ll learn how to use the DBMS to add new data.

# 15.3. Lesson: Adding Data to the Model [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/adding_data.html#ls-adding-data-to-the-model "Permalink to this headline")

The models we’ve created will now need to be populated with the data they’re intended to contain.

**The goal for this lesson:** To learn how to insert new data into the database models.

## 15.3.1. Insert statement [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/adding_data.html#insert-statement "Permalink to this headline")

How do you add data to a table? The sql INSERT statement provides the functionality for this:

```
insert into streets (name) values ('High street');

```

Copy to clipboard

A couple of things to note:

-   After the table name (streets), you list the column names that you will be populating (in this case only the name column).
    
-   After the values keyword, place the list of field values.
    
-   Strings should be quoted using single quotes.
    
-   Note that we did not insert a value for the id column; this is because it is a sequence and will be auto-generated.
    
-   If you do manually set the id, you may cause serious problems with the integrity of your database.
    

You should see INSERT 0 1 if it is successful.

You can see the result of your insert action by selecting all the data in the table:

```
select * from streets;

```

Copy to clipboard

Result:

```
select * from streets;
 id |    name
----+-------------
  1 | High street
(1 row)

```

Copy to clipboard

### Try Yourself ![basic](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/adding_data.html../../../_images/basic.png) [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/adding_data.html#ty-basic "Permalink to this headline")

Use the INSERT command to add a new street to the streets table.

Answer

The SQL command you should use looks like this (you can replace the street name with a name of your choice):

```
insert into streets (name) values ('Low Road');

```

Copy to clipboard

## 15.3.2. Sequencing Data Addition According to Constraints [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/adding_data.html#sequencing-data-addition-according-to-constraints "Permalink to this headline")

## 15.3.3. Try Yourself ![moderate](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/adding_data.html../../../_images/moderate.png) [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/adding_data.html#ty-moderate "Permalink to this headline")

Try to add a person object to the people table with the following details:

```
Name: Joe Smith
House Number: 55
Street: Main Street
Phone: 072 882 33 21

```

Copy to clipboard

Note

Recall that in this example, we defined phone numbers as strings, not integers.

At this point, you should have an error report if you try to do this without first creating a record for Main Street in the streets table.

You should have also noticed that:

-   You can’t add the street using its name
    
-   You can’t add a street using a street id before first creating the street record on the streets table
    

Remember that our two tables are linked via a Primary/Foreign Key pair. This means that no valid person can be created without there also being a valid corresponding street record.

Using the above knowledge, add the new person to the database.

Answer

Here is the correct SQL statement:

```
insert into streets (name) values('Main Road');
insert into people (name,house_no, street_id, phone_no)
  values ('Joe Smith',55,2,'072 882 33 21');

```

Copy to clipboard

If you look at the streets table again (using a select statement as before), you’ll see that the id for the `Main Road` entry is _2_.

That’s why we could merely enter the number `2` above. Even though we’re not seeing `Main Road` written out fully in the entry above, the database will be able to associate that with the street\_id value of _2_.

If you have already added a new street object, you might find that the new `Main Road` has an id of _3_ not _2_.

## 15.3.4. Select data [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/adding_data.html#select-data "Permalink to this headline")

We have already shown you the syntax for selecting records. Let’s look at a few more examples:

```
select name from streets;

```

Copy to clipboard

```
select * from streets;

```

Copy to clipboard

```
select * from streets where name='Main Road';

```

Copy to clipboard

In later sessions we will go into more detail on how to select and filter data.

## 15.3.5. Update data [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/adding_data.html#update-data "Permalink to this headline")

What if you want to make a change to some existing data? For example, a street name is changed:

```
update streets set name='New Main Road' where name='Main Road';

```

Copy to clipboard

Be very careful using such update statements - if more than one record matches your WHERE clause, they will all be updated!

A better solution is to use the primary key of the table to reference the record to be changed:

```
update streets set name='New Main Road' where id=2;

```

Copy to clipboard

It should return UPDATE 1.

Note

the WHERE statement criteria are case sensitive Main Road is not the same as Main road

## 15.3.6. Delete Data [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/adding_data.html#delete-data "Permalink to this headline")

In order to delete an object from a table, use the DELETE command:

```
delete from people where name = 'Joe Smith';

```

Copy to clipboard

Let’s look at our people table now:

```
address=# select * from people;

  id | name | house_no | street_id | phone_no
 ----+------+----------+-----------+----------
(0 rows)

```

Copy to clipboard

## 15.3.7. Try Yourself ![hard](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/adding_data.html../../../_images/hard.png) [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/adding_data.html#ty-hard "Permalink to this headline")

Use the skills you have learned to add some new friends to your database:

```
      name       | house_no | street_id |   phone_no
-----------------+----------+-----------+--------------
Joe Bloggs       |        3 |         2 | 072 887 23 45
Jane Smith       |       55 |         3 | 072 837 33 35
Roger Jones      |       33 |         1 | 072 832 31 38
Sally Norman     |       83 |         1 | 072 932 31 32

```

Copy to clipboard

## 15.3.8. In Conclusion [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/adding_data.html#ic "Permalink to this headline")

Now you know how to add new data to the existing models you created previously. Remember that if you want to add new kinds of data, you may want to modify and/or create new models to contain that data.

## 15.3.9. What’s Next? [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/adding_data.html#wn "Permalink to this headline")

Now that you’ve added some data, you’ll learn how to use queries to access this data in various ways.

# 15.4. Lesson: Queries [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/queries.html#ls-queries "Permalink to this headline")

When you write a SELECT ... command it is commonly known as a query - you are interrogating the database for information.

**The goal of this lesson:** To learn how to create queries that will return useful information.

Note

If you did not do so in the previous lesson, add the following people objects to your people table. If you receive any errors related to foreign key constraints, you will need to add the ‘Main Road’ object to your streets table first

```
insert into people (name,house_no, street_id, phone_no)
          values ('Joe Bloggs',3,2,'072 887 23 45');
insert into people (name,house_no, street_id, phone_no)
          values ('Jane Smith',55,3,'072 837 33 35');
insert into people (name,house_no, street_id, phone_no)
          values ('Roger Jones',33,1,'072 832 31 38');
insert into people (name,house_no, street_id, phone_no)
          values ('Sally Norman',83,1,'072 932 31 32');

```

Copy to clipboard

## 15.4.1. Ordering Results [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/queries.html#ordering-results "Permalink to this headline")

Let’s retrieve a list of people ordered by their house numbers:

```
select name, house_no from people order by house_no;

```

Copy to clipboard

Result:

```
     name     | house_no
--------------+----------
 Joe Bloggs   |        3
 Roger Jones  |       33
 Jane Smith   |       55
 Sally Norman |       83
(4 rows)

```

Copy to clipboard

You can sort the results by the values of more than one column:

```
select name, house_no from people order by name, house_no;

```

Copy to clipboard

Result:

```
     name     | house_no
--------------+----------
 Jane Smith   |       55
 Joe Bloggs   |        3
 Roger Jones  |       33
 Sally Norman |       83
(4 rows)

```

Copy to clipboard

## 15.4.2. Filtering [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/queries.html#filtering "Permalink to this headline")

Often you won’t want to see every single record in the database - especially if there are thousands of records and you are only interested in seeing one or two.

Here is an example of a numerical filter which only returns objects whose `house_no` is less than 50:

```
select name, house_no from people where house_no < 50;

      name     | house_no
  -------------+----------
   Joe Bloggs  |        3
   Roger Jones |       33
  (2 rows)

```

Copy to clipboard

You can combine filters (defined using the `WHERE` clause) with sorting (defined using the `ORDER BY` clause):

```
select name, house_no from people where house_no < 50 order by house_no;

      name     | house_no
  -------------+----------
   Joe Bloggs  |        3
   Roger Jones |       33
  (2 rows)

```

Copy to clipboard

You can also filter based on text data:

```
select name, house_no from people where name like '%s%';

      name     | house_no
  -------------+----------
   Joe Bloggs  |        3
   Roger Jones |       33
  (2 rows)

```

Copy to clipboard

Here we used the LIKE clause to find all names with an s in them. You’ll notice that this query is case-sensitive, so the Sally Norman entry has not been returned.

If you want to search for a string of letters regardless of case, you can do a case in-sensitive search using the ILIKE clause:

```
select name, house_no from people where name ilike '%r%';

       name     | house_no
  --------------+----------
   Roger Jones  |       33
   Sally Norman |       83
  (2 rows)

```

Copy to clipboard

That query returned every **people** object with an r or R in their name.

## 15.4.3. Joins [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/queries.html#joins "Permalink to this headline")

What if you want to see the person’s details and their street’s name instead of the ID? In order to do that, you need to join the two tables together in a single query. Lets look at an example:

```
select people.name, house_no, streets.name
from people,streets
where people.street_id=streets.id;

```

Copy to clipboard

Note

With joins, you will always state the two tables the information is coming from, in this case people and streets. You also need to specify which two keys must match (foreign key & primary key). If you don’t specify that, you will get a list of all possible combinations of people and streets, but no way to know who actually lives on which street!

Here is what the correct output will look like:

```
     name     | house_no |    name
--------------+----------+-------------
 Joe Bloggs   |        3 | Low Street
 Roger Jones  |       33 | High street
 Sally Norman |       83 | High street
 Jane Smith   |       55 | Main Road
(4 rows)

```

Copy to clipboard

We will revisit joins as we create more complex queries later. Just remember they provide a simple way to combine the information from two or more tables.

## 15.4.4. Sub-Select [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/queries.html#sub-select "Permalink to this headline")

Sub-selections allow you to select objects from one table based on the data from another table which is linked via a foreign key relationship. In our case, we want to find people who live on a specific street.

First, let’s do a little tweaking of our data:

```
insert into streets (name) values('QGIS Road');
insert into streets (name) values('OGR Corner');
insert into streets (name) values('Goodle Square');
update people set street_id = 2 where id=2;
update people set street_id = 3 where id=3;

```

Copy to clipboard

Let’s take a quick look at our data after those changes: we can reuse our query from the previous section:

```
select people.name, house_no, streets.name
from people,streets
where people.street_id=streets.id;

```

Copy to clipboard

Result:

```
     name     | house_no |    name
--------------+----------+-------------
 Roger Jones  |       33 | High street
 Sally Norman |       83 | High street
 Jane Smith   |       55 | Main Road
 Joe Bloggs   |        3 | Low Street
(4 rows)

```

Copy to clipboard

Now let’s show you a sub-selection on this data. We want to show only people who live in `street_id` number 1:

```
select people.name
from people, (
    select *
    from streets
    where id=1
  ) as streets_subset
where people.street_id = streets_subset.id;

```

Copy to clipboard

Result:

```
     name
--------------
 Roger Jones
 Sally Norman
(2 rows)

```

Copy to clipboard

Although this is a very simple example and unnecessary with our small data-sets, it illustrates how useful and important sub-selections can be when querying large and complex data-sets.

## 15.4.5. Aggregate Queries [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/queries.html#aggregate-queries "Permalink to this headline")

One of the powerful features of a database is its ability to summarise the data in its tables. These summaries are called aggregate queries. Here is a typical example which tells us how many people objects are in our people table:

```
select count(*) from people;

```

Copy to clipboard

Result:

```
 count
-------
     4
(1 row)

```

Copy to clipboard

If we want the counts to be summarised by street name we can do this:

```
select count(name), street_id
from people
group by street_id;

```

Copy to clipboard

Result:

```
 count | street_id
-------+-----------
     2 |         1
     1 |         3
     1 |         2
(3 rows)

```

Copy to clipboard

Note

Because we have not used an ORDER BY clause, the order of your results may not match what is shown here.

### Try Yourself ![moderate](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/queries.html../../../_images/moderate.png) [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/queries.html#ty-moderate "Permalink to this headline")

Summarise the people by street name and show the actual street names instead of the street\_ids.

Answer

Here is the correct SQL statement you should use:

```
select count(people.name), streets.name
from people, streets
where people.street_id=streets.id
group by streets.name;

```

Copy to clipboard

Result:

```
count |    name
------+-------------
    1 | Low Street
    2 | High street
    1 | Main Road
(3 rows)

```

Copy to clipboard

You will notice that we have prefixed field names with table names (e.g. people.name and streets.name). This needs to be done whenever the field name is ambiguous (i.e. not unique across all tables in the database).

## 15.4.6. In Conclusion [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/queries.html#ic "Permalink to this headline")

You’ve seen how to use queries to return the data in your database in a way that allows you to extract useful information from it.

## 15.4.7. What’s Next? [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/queries.html#wn "Permalink to this headline")

Next you’ll see how to create views from the queries that you’ve written.


# 15.5. Lesson: Views [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/views.html#ls-views "Permalink to this headline")

When you write a query, you need to spend a lot of time and effort formulating it. With views, you can save the definition of an SQL query in a reusable ‘virtual table’.

**The goal for this lesson:** To save a query as a view.

## 15.5.1. Creating a View [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/views.html#creating-a-view "Permalink to this headline")

You can treat a view just like a table, but its data is sourced from a query. Let’s make a simple view based on the above:

```
create view roads_count_v as
  select count(people.name), streets.name
  from people, streets where people.street_id=streets.id
  group by people.street_id, streets.name;

```

Copy to clipboard

As you can see the only change is the create view roads\_count\_v as part at the beginning. We can now select data from that view:

```
select * from roads_count_v;

```

Copy to clipboard

Result:

```
 count |    name
-------+-------------
     1 | Main Road
     2 | High street
     1 | Low Street
(3 rows)

```

Copy to clipboard

## 15.5.2. Modifying a View [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/views.html#modifying-a-view "Permalink to this headline")

A view is not fixed, and it contains no ‘real data’. This means you can easily change it without impacting on any data in your database:

```
CREATE OR REPLACE VIEW roads_count_v AS
  SELECT count(people.name), streets.name
  FROM people, streets WHERE people.street_id=streets.id
  GROUP BY people.street_id, streets.name
  ORDER BY streets.name;

```

Copy to clipboard

(This example also shows the best practice convention of using UPPER CASE for all SQL keywords.)

You will see that we have added an ORDER BY clause so that our view rows are nicely sorted:

```
select * from roads_count_v;

 count |    name
-------+-------------
     2 | High street
     1 | Low Street
     1 | Main Road
(3 rows)

```

Copy to clipboard

## 15.5.3. Dropping a View [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/views.html#dropping-a-view "Permalink to this headline")

If you no longer need a view, you can delete it like this:

```
drop view roads_count_v;

```

Copy to clipboard

## 15.5.4. In Conclusion [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/views.html#ic "Permalink to this headline")

Using views, you can save a query and access its results as if it were a table.

## 15.5.5. What’s Next? [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/views.html#wn "Permalink to this headline")

Sometimes, when changing data, you want your changes to have effects elsewhere in the database. The next lesson will show you how to do this.


# 15.6. Lesson: Rules [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/rules.html#ls-rules "Permalink to this headline")

Rules allow the “query tree” of an incoming query to be rewritten. One common usage is to implement views, including updatable view. _\- Wikipedia_

**The goal for this lesson:** To learn how to create new rules for the database.

## 15.6.1. Creating a logging rule [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/rules.html#creating-a-logging-rule "Permalink to this headline")

Say you want to log every change of phone\_no in your people table in to a people\_log table. So you set up a new table:

```
create table people_log (name text, time timestamp default NOW());

```

Copy to clipboard

In the next step, create a rule that logs every change of a phone\_no in the people table into the people\_log table:

```
create rule people_log as on update to people
  where NEW.phone_no <> OLD.phone_no
  do insert into people_log values (OLD.name);

```

Copy to clipboard

To test that the rule works, let’s modify a phone number:

```
update people set phone_no = '082 555 1234' where id = 2;

```

Copy to clipboard

Check that the people table was updated correctly:

```
select * from people where id=2;

 id |    name    | house_no | street_id |   phone_no
----+------------+----------+-----------+--------------
  2 | Joe Bloggs |        3 |         2 | 082 555 1234
(1 row)

```

Copy to clipboard

Now, thanks to the rule we created, the people\_log table will look like this:

```
select * from people_log;

    name    |            time
------------+----------------------------
 Joe Bloggs | 2014-01-11 14:15:11.953141
(1 row)

```

Copy to clipboard

Note

The value of the time field will depend on the current date and time.

## 15.6.2. In Conclusion [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/rules.html#ic "Permalink to this headline")

Rules allow you to automatically add or change data in your database to reflect changes in other parts of the database.

## 15.6.3. What’s Next? [#](https://docs.qgis.org/3.28/en/docs/training_manual/database_concepts/rules.html#wn "Permalink to this headline")

The next module will introduce you to Spatial Database using PostGIS, which takes these database concepts and applies them to GIS data.

# 16.1. Lesson: PostGIS Setup [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/spatial_functions.html#ls-postgis-setup "Permalink to this headline")

Setting up PostGIS functions will allow you to access spatial functions from within PostgreSQL.

**The goal for this lesson:** To install spatial functions and briefly demo their effects.

Note

We will assume the use of PostGIS version 2.1 or newer in this exercise. The installation and database configuration are different for older versions, but the rest of this material in this module will still work. Consult the documentation for your platform for help with installation and database configuration.

## 16.1.1. Installing under Ubuntu [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/spatial_functions.html#installing-under-ubuntu "Permalink to this headline")

Postgis is easily installed from apt.

```
$ sudo apt install postgresql
$ sudo apt install postgis

```

Copy to clipboard

Really, it’s that easy…

Note

The exact versions that will be installed depend on which version of Ubuntu you are using and which repositories you have configured. After installing you can check the version by issuing a `select PostGIS_full_version();` query with psql or another tool.

To install a specific version (eg, PostgreSQL version 13 and PostGIS 3), you can use the following commands.

```
$ sudo apt install wget ca-certificates
$ sudo lsb_release -a
$ wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -
$ sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt/ `lsb_release -cs`-pgdg main" >> /etc/apt/sources.list.d/pgdg.list'
$ sudo apt-get update
$ sudo apt install postgis postgresql-13-postgis-3

```

Copy to clipboard

## 16.1.2. Installing under Windows [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/spatial_functions.html#installing-under-windows "Permalink to this headline")

Installing on Windows can be done from binary packages using a normal Windows installation dialogs.

First Visit [the download page](https://www.postgresql.org/download/). Then follow [this guide](https://www.bostongis.com/PrinterFriendly.aspx?content_name=postgis_tut01).

More information about installing on Windows can be found on the [PostGIS website](https://postgis.net/windows_downloads).

## 16.1.3. Installing on Other Platforms [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/spatial_functions.html#installing-on-other-platforms "Permalink to this headline")

The [PostGIS website download](https://postgis.net/install/) has information about installing on other platforms including macOS and on other Linux distributions

## 16.1.4. Configuring Databases to use PostGIS [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/spatial_functions.html#configuring-databases-to-use-postgis "Permalink to this headline")

Once PostGIS is installed, you will need to configure your database to use the extensions. If you have installed PostGIS version > 2.0, this is as simple as issuing the following command with psql using the address database from our previous exercise.

```
$ psql -d address -c "CREATE EXTENSION postgis;"

```

Copy to clipboard

Note

Depending on your version, you could find more instructions on how to spatially enable a database at [https://postgis.net/docs/postgis\_administration.html#create\_spatial\_db](https://postgis.net/docs/postgis_administration.html#create_spatial_db).

## 16.1.5. Looking at the installed PostGIS functions [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/spatial_functions.html#looking-at-the-installed-postgis-functions "Permalink to this headline")

PostGIS can be thought of as a collection of in-database functions that extend the core capabilities of PostgreSQL so that it can deal with spatial data. By ‘deal with’, we mean store, retrieve, query and manipulate. In order to do this, a number of functions are installed into the database.

Our PostgreSQL `address` database is now geospatially enabled, thanks to PostGIS. We are going to delve a lot deeper into this in the coming sections, but let’s give you a quick little taster. Let’s say we want to create a point from text. First we use the psql command to find functions relating to point. If you are not already connected to the `address` database, do so now. Then run:

```
\df *point*

```

Copy to clipboard

This is the command we’re looking for: st\_pointfromtext. To page through the list, use the down arrow, then press Q to quit back to the psql shell.

Try running this command:

```
select st_pointfromtext('POINT(1 1)');

```

Copy to clipboard

Result:

```
st_pointfromtext
--------------------------------------------
0101000000000000000000F03F000000000000F03F
(1 row)

```

Copy to clipboard

Three things to note:

-   We defined a point at position 1,1 (EPSG:4326 is assumed) using POINT(1 1),
    
-   We ran an sql statement, but not on any table, just on data entered from the SQL prompt,
    
-   The resulting row does not make much sense.
    

The resulting row is in the OGC format called ‘Well Known Binary’ (WKB). We will look at this format in detail in the next section.

To get the results back as text, we can do a quick scan through the function list for something that returns text:

```
\df *text

```

Copy to clipboard

The query we’re looking for now is `st_astext`. Let’s combine it with the previous query:

```
select st_astext(st_pointfromtext('POINT(1 1)'));

```

Copy to clipboard

Result:

```
 st_astext
------------
  POINT(1 1)
  (1 row)

```

Copy to clipboard

Here, we entered the string POINT(1,1), turned it into a point using st\_pointfromtext(), and turned it back into a human-readable form with st\_astext(), which gave us back our original string.

One last example before we really get into the detail of using PostGIS:

```
select st_astext(st_buffer(st_pointfromtext('POINT(1 1)'),1.0));

```

Copy to clipboard

What did that do? It created a buffer of 1 degree around our point, and returned the result as text.

## 16.1.6. Spatial Reference Systems [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/spatial_functions.html#spatial-reference-systems "Permalink to this headline")

In addition to the PostGIS functions, the extension contains a collection of spatial reference system (SRS) definitions as defined by the European Petroleum Survey Group (EPSG). These are used during operations such as coordinate reference system (CRS) conversions.

We can inspect these SRS definitions in our database as they are stored in normal database tables.

First, let’s look at the schema of the table by entering the following command in the psql prompt:

```
\d spatial_ref_sys

```

Copy to clipboard

The result should be this:

```
Table "public.spatial_ref_sys"
   Column   |          Type           | Modifiers
 -----------+-------------------------+-----------
  srid      | integer                 | not null
  auth_name | character varying(256)  |
  auth_srid | integer                 |
  srtext    | character varying(2048) |
  proj4text | character varying(2048) |
  Indexes:
"spatial_ref_sys_pkey" PRIMARY KEY, btree (srid)

```

Copy to clipboard

You can use standard SQL queries (as we have learned from our introductory sections), to view and manipulate this table - though its not a good idea to update or delete any records unless you know what you are doing.

One SRID you may be interested in is EPSG:4326 - the geographic / lat lon reference system using the WGS 84 ellipsoid. Let’s take a look at it:

```
select * from spatial_ref_sys where srid=4326;

```

Copy to clipboard

Result:

```
srid      | 4326
auth_name | EPSG
auth_srid | 4326
srtext    | GEOGCS["WGS 84",DATUM["WGS_1984",SPHEROID["WGS
84",6378137,298.257223563,AUTHORITY["EPSG","7030"]],TOWGS84[0,
0,0,0,0,0,0],AUTHORITY["EPSG","6326"]],PRIMEM["Greenwich",0,
AUTHORITY["EPSG","8901"]],UNIT["degree",0.01745329251994328,
AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4326"]]
proj4text | +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs

```

Copy to clipboard

The srtext is the projection definition in well known text (you may recognise this from .prj files in your shapefile collection).

## 16.1.7. In Conclusion [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/spatial_functions.html#ic "Permalink to this headline")

You now have PostGIS functions installed in your copy of PostgreSQL. With this you’ll be able to make use of PostGIS’ extensive spatial functions.

## 16.1.8. What’s Next? [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/spatial_functions.html#wn "Permalink to this headline")

Next you’ll learn how spatial features are represented in a database.

# 16.2. Lesson: Simple Feature Model [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/simple_feature_model.html#ls-simple-feature-model "Permalink to this headline")

How can we store and represent geographic features in a database? In this lesson we’ll cover one approach, the Simple Feature Model as defined by the OGC.

**The goal for this lesson:** To learn what the SFS Model is and how to use it.

## 16.2.1. What is OGC [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/simple_feature_model.html#what-is-ogc "Permalink to this headline")

The Open Geospatial Consortium (OGC), an international voluntary consensus standards organization, originated in 1994. In the OGC, more than 370+ commercial, governmental, nonprofit and research organizations worldwide collaborate in an open consensus process encouraging development and implementation of standards for geospatial content and services, GIS data processing and data sharing. _\- Wikipedia_

## 16.2.2. What is the SFS Model [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/simple_feature_model.html#what-is-the-sfs-model "Permalink to this headline")

The Simple Feature for SQL (SFS) Model is a _non-topological_ way to store geoespacial data in a database and defines functions for accessing, operating, and constructing these data.

![../../../_images/ogc_sfs.png](https://docs.qgis.org/3.28/en/_images/ogc_sfs.png)

The model defines geospatial data from Point, Linestring, and Polygon types (and aggregations of them to Multi objects).

For further information, have a look at the [OGC Simple Feature for SQL](https://www.ogc.org/standards/sfs) standard.

## 16.2.3. Add a geometry field to table [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/simple_feature_model.html#add-a-geometry-field-to-table "Permalink to this headline")

Let’s add a point field to our people table:

```
alter table people add column the_geom geometry;

```

Copy to clipboard

## 16.2.4. Add a constraint based on geometry type [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/simple_feature_model.html#add-a-constraint-based-on-geometry-type "Permalink to this headline")

You will notice that the geometry field type does not implicitly specify what _type_ of geometry for the field - for that we need a constraint:

```
alter table people
add constraint people_geom_point_chk
    check(st_geometrytype(the_geom) = 'ST_Point'::text
          OR the_geom IS NULL);

```

Copy to clipboard

This adds a constraint to the table so that it will only accept a point geometry or a null value.

## 16.2.5. Try Yourself ![hard](https://docs.qgis.org/3.28/en/_images/hard.png) [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/simple_feature_model.html#ty-hard "Permalink to this headline")

Create a new table called cities and give it some appropriate columns, including a geometry field for storing polygons (the city boundaries). Make sure it has a constraint enforcing geometries to be polygons.

Answer

```
create table cities (id serial not null primary key,
                     name varchar(50),
                     the_geom geometry not null);
 alter table cities
 add constraint cities_geom_point_chk
 check (st_geometrytype(the_geom) = 'ST_Polygon'::text );

```

Copy to clipboard

## 16.2.6. Populate geometry\_columns table [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/simple_feature_model.html#populate-geometry-columns-table "Permalink to this headline")

At this point you should also add an entry into the `geometry_columns` table:

```
insert into geometry_columns values
  ('','public','people','the_geom',2,4326,'POINT');

```

Copy to clipboard

Why? geometry\_columns is used by certain applications to be aware of which tables in the database contain geometry data.

Note

If the above `INSERT` statement causes an error, run this query first:

```
select * from geometry_columns;

```

Copy to clipboard

If the column f\_table\_name contains the value people, then this table has already been registered and you don’t need to do anything more.

The value `2` refers to the number of dimensions; in this case, two: **X** and **Y**.

The value 4326 refers to the projection we are using; in this case, WGS 84, which is referred to by the number 4326 (refer to the earlier discussion about the EPSG).

### Try Yourself ![basic](https://docs.qgis.org/3.28/en/_images/basic.png) [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/simple_feature_model.html#ty-basic "Permalink to this headline")

Add an appropriate geometry\_columns entry for your new cities layer

Answer

```
insert into geometry_columns values
      ('','public','cities','the_geom',2,4326,'POLYGON');

```

Copy to clipboard

## 16.2.7. Add geometry record to table using SQL [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/simple_feature_model.html#add-geometry-record-to-table-using-sql "Permalink to this headline")

Now that our tables are geo-enabled, we can store geometries in them:

```
insert into people (name,house_no, street_id, phone_no, the_geom)
        values ('Fault Towers',
                 34,
                 3,
                 '072 812 31 28',
                 'SRID=4326;POINT(33 -33)');

```

Copy to clipboard

Note

In the new entry above, you will need to specify which projection (SRID) you want to use. This is because you entered the geometry of the new point using a plain string of text, which does not automatically add the correct projection information. Obviously, the new point needs to use the same SRID as the data-set it is being added to, so you need to specify it.

If at this point you were using a graphical interface, for example, specifying the projection for each point would be automatic. In other words, you usually won’t need to worry about using the correct projection for every point you want to add if you’ve already specified it for that data-set, as we did earlier.

Now is probably a good time to open QGIS and try to view your people table. Also, we should try editing / adding / deleting records and then performing select queries in the database to see how the data has changed.

To load a PostGIS layer in QGIS, use the Layer ► Add PostGIS Layers menu option or toolbar button:

> [![addPostgisLayer](https://docs.qgis.org/3.28/en/_images/mActionAddPostgisLayer.png)](https://docs.qgis.org/3.28/en/_images/mActionAddPostgisLayer.png)

This will open the dialog:

![../../../_images/add_postgis_layer_dialog.png](https://docs.qgis.org/3.28/en/_images/add_postgis_layer_dialog.png)

Click on the New button to open this dialog:

![../../../_images/new_postgis_connection.png](https://docs.qgis.org/3.28/en/_images/new_postgis_connection.png)

Then define a new connection, e.g.:

```
Name: myPG
Service:
Host: localhost
Port: 5432
Database: address
User:
Password:

```

Copy to clipboard

To see whether QGIS has found the address database and that your username and password are correct, click Test Connect. If it works, check the boxes next to Save Username and Save Password. Then click OK to create this connection.

Back in the Add PostGIS Layers dialog, click Connect and add layers to your project as usual.

### Try Yourself ![moderate](https://docs.qgis.org/3.28/en/_images/moderate.png) [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/simple_feature_model.html#ty-moderate "Permalink to this headline")

Formulate a query that shows a person’s name, street name and position (from the the\_geom column) as plain text.

Answer

```
select people.name,
       streets.name as street_name,
       st_astext(people.the_geom) as geometry
from   streets, people
where  people.street_id=streets.id;

```

Copy to clipboard

Result:

```
     name     | street_name |   geometry
--------------+-------------+---------------
 Roger Jones  | High street |
 Sally Norman | High street |
 Jane Smith   | Main Road   |
 Joe Bloggs   | Low Street  |
 Fault Towers | Main Road   | POINT(33 -33)
(5 rows)

```

Copy to clipboard

As you can see, our constraint allows nulls to be added into the database.

## 16.2.8. In Conclusion [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/simple_feature_model.html#ic "Permalink to this headline")

You have seen how to add spatial objects to your database and view them in GIS software.

## 16.2.9. What’s Next? [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/simple_feature_model.html#wn "Permalink to this headline")

Next you’ll see how to import data into, and export data from, your database.

# 16.3. Lesson: Import and Export [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/import_export.html#ls-import-and-export "Permalink to this headline")

Of course, a database with no easy way to migrate data into it and out of it would not be of much use. Fortunately, there are a number of tools that will let you easily move data into and out of PostGIS.

## 16.3.1. shp2pgsql [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/import_export.html#shp2pgsql "Permalink to this headline")

shp2pgsql is a commandline tool to import ESRI Shapefile to the database. Under Unix, you can use the following command for importing a new PostGIS table:

```
shp2pgsql -s <SRID> -c -D -I <path to shapefile> <schema>.<table> | \
  psql -d <databasename> -h <hostname> -U <username>

```

Copy to clipboard

Under Windows, you have to perform the import process in two steps:

```
shp2pgsql -s <SRID> -c -D -I <path to shapefile> <schema>.<table> > import.sql
psql psql -d <databasename> -h <hostname> -U <username> -f import.sql

```

Copy to clipboard

You may encounter this error:

```
ERROR:  operator class "gist_geometry_ops" does not exist for access method
"gist"

```

Copy to clipboard

This is a known issue regarding the creation _in situ_ of a spatial index for the data you’re importing. To avoid the error, exclude the `-I` parameter. This will mean that no spatial index is being created directly, and you’ll need to create it in the database after the data have been imported. (The creation of a spatial index will be covered in the next lesson.)

## 16.3.2. pgsql2shp [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/import_export.html#pgsql2shp "Permalink to this headline")

pgsql2shp is a commandline tool to export PostGIS Tables, Views or SQL select queries. To do this under Unix:

```
pgsql2shp -f <path to new shapefile> -g <geometry column name> \
  -h <hostname> -U <username> <databasename> <table | view>

```

Copy to clipboard

To export the data using a query:

```
pgsql2shp -f <path to new shapefile> -g <geometry column name> \
  -h <hostname> -U <username> "<query>"

```

Copy to clipboard

## 16.3.3. ogr2ogr [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/import_export.html#ogr2ogr "Permalink to this headline")

ogr2ogr is a very powerful tool to convert data into and from postgis to many data formats. ogr2ogr is part of the GDAL library and has to be installed separately. To export a table from PostGIS to GML, you can use this command:

```
ogr2ogr -f GML export.gml PG:'dbname=<databasename> user=<username>
        host=<hostname>' <Name of PostGIS-Table>

```

Copy to clipboard

## 16.3.4. DB Manager [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/import_export.html#db-manager "Permalink to this headline")

You may have noticed another option in the Database menu labeled DB Manager. This is a tool that provides a unified interface for interacting with spatial databases including PostGIS. It also allows you to import and export from databases to other formats. Since the next module is largely devoted to using this tool, we will only briefly mention it here.

## 16.3.5. In Conclusion [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/import_export.html#ic "Permalink to this headline")

Importing and exporting data to and from the database can be done in many various ways. Especially when using disparate data sources, you will probably use these functions (or others like them) on a regular basis.

## 16.3.6. What’s Next? [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/import_export.html#wn "Permalink to this headline")

Next we’ll look at how to query the data we’ve created before.

# 16.4. Lesson: Spatial Queries [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/spatial_queries.html#ls-spatial-queries "Permalink to this headline")

Spatial queries are no different from other database queries. You can use the geometry column like any other database column. With the installation of PostGIS in our database, we have additional functions to query our database.

**The goal for this lesson:** To see how spatial functions are implemented similarly to “normal” non-spatial functions.

## 16.4.1. Spatial Operators [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/spatial_queries.html#spatial-operators "Permalink to this headline")

When you want to know which points are within a distance of 2 degrees to a point(X,Y) you can do this with:

```
select *
from people
where st_distance(the_geom,'SRID=4326;POINT(33 -34)') < 2;

```

Copy to clipboard

Result:

```
 id |     name     | house_no | street_id |   phone_no    |   the_geom
----+--------------+----------+-----------+---------------+---------------
  6 | Fault Towers |       34 |         3 | 072 812 31 28 | 01010008040C0
(1 row)

```

Copy to clipboard

Note

the\_geom value above was truncated for space on this page. If you want to see the point in human-readable coordinates, try something similar to what you did in the section “View a point as WKT”, above.

How do we know that the query above returns all the points within 2 _degrees_? Why not 2 _meters_? Or any other unit, for that matter?

Answer

The units being used by the example query are degrees, because the CRS that the layer is using is WGS 84. This is a Geographic CRS, which means that its units are in degrees. A Projected CRS, like the UTM projections, is in meters.

Remember that when you write a query, you need to know which units the layer’s CRS is in. This will allow you to write a query that will return the results that you expect.

## 16.4.2. Spatial Indexes [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/spatial_queries.html#spatial-indexes "Permalink to this headline")

We also can define spatial indexes. A spatial index makes your spatial queries much faster. To create a spatial index on the geometry column use:

```
CREATE INDEX people_geo_idx
  ON people
  USING gist
  (the_geom);

\d people

```

Copy to clipboard

Result:

```
Table "public.people"
   Column   |         Type          |                Modifiers
 -----------+-----------------------+----------------------------------------
  id        | integer               | not null default
            |                       | nextval('people_id_seq'::regclass)
  name      | character varying(50) |
  house_no  | integer               | not null
  street_id | integer               | not null
  phone_no  | character varying     |
  the_geom  | geometry              |
Indexes:
  "people_pkey" PRIMARY KEY, btree (id)
  "people_geo_idx" gist (the_geom)  <-- new spatial key added
  "people_name_idx" btree (name)
Check constraints:
  "people_geom_point_chk" CHECK (st_geometrytype(the_geom) = 'ST_Point'::text
  OR the_geom IS NULL)
Foreign-key constraints:
  "people_street_id_fkey" FOREIGN KEY (street_id) REFERENCES streets(id)

```

Copy to clipboard

## 16.4.3. Try Yourself ![moderate](https://docs.qgis.org/3.28/en/_images/moderate.png) [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/spatial_queries.html#ty-moderate "Permalink to this headline")

Modify the cities table so its geometry column is spatially indexed.

Answer

```
CREATE INDEX cities_geo_idx
  ON cities
  USING gist (the_geom);

```

Copy to clipboard

## 16.4.4. PostGIS Spatial Functions Demo [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/spatial_queries.html#postgis-spatial-functions-demo "Permalink to this headline")

In order to demo PostGIS spatial functions, we’ll create a new database containing some (fictional) data.

To start, create a new database (exit the psql shell first):

```
createdb postgis_demo

```

Copy to clipboard

Remember to install the postgis extensions:

```
psql -d postgis_demo -c "CREATE EXTENSION postgis;"

```

Copy to clipboard

Next, import the data provided in the exercise\_data/postgis/ directory. Refer back to the previous lesson for instructions, but remember that you’ll need to create a new PostGIS connection to the new database. You can import from the terminal or via DB Manager. Import the files into the following database tables:

-   points.shp into building
    
-   lines.shp into road
    
-   polygons.shp into region
    

Load these three database layers into QGIS via the Add PostGIS Layers dialog, as usual. When you open their attribute tables, you’ll note that they have both an id field and a gid field created by the PostGIS import.

Now that the tables are imported, we can use PostGIS to query the data. Go back to your terminal (command line) and enter the psql prompt by running:

```
psql postgis_demo

```

Copy to clipboard

We’ll demo some of these select statements by creating views from them, so that you can open them in QGIS and see the results.

### Select by location [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/spatial_queries.html#select-by-location "Permalink to this headline")

Get all the buildings in the KwaZulu region:

```
SELECT a.id, a.name, st_astext(a.the_geom) as point
  FROM building a, region b
    WHERE st_within(a.the_geom, b.the_geom)
    AND b.name = 'KwaZulu';

```

Copy to clipboard

Result:

```
 id | name |                  point
----+------+------------------------------------------
 30 | York | POINT(1622345.23785063 6940490.65844485)
 33 | York | POINT(1622495.65620524 6940403.87862489)
 35 | York | POINT(1622403.09106394 6940212.96302097)
 36 | York | POINT(1622287.38463732 6940357.59605424)
 40 | York | POINT(1621888.19746548 6940508.01440885)
(5 rows)

```

Copy to clipboard

Or, if we create a view from it:

```
CREATE VIEW vw_select_location AS
  SELECT a.gid, a.name, a.the_geom
    FROM building a, region b
      WHERE st_within(a.the_geom, b.the_geom)
      AND b.name = 'KwaZulu';

```

Copy to clipboard

Add the view as a layer and view it in QGIS:

![../../../_images/kwazulu_view_result.png](https://docs.qgis.org/3.28/en/_images/kwazulu_view_result.png)

### Select neighbors [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/spatial_queries.html#select-neighbors "Permalink to this headline")

Show a list of all the names of regions adjoining the Hokkaido region:

```
SELECT b.name
  FROM region a, region b
    WHERE st_touches(a.the_geom, b.the_geom)
    AND a.name = 'Hokkaido';

```

Copy to clipboard

Result:

```
    name
--------------
 Missouri
 Saskatchewan
 Wales
(3 rows)

```

Copy to clipboard

As a view:

```
CREATE VIEW vw_regions_adjoining_hokkaido AS
  SELECT b.gid, b.name, b.the_geom
    FROM region a, region b
      WHERE st_touches(a.the_geom, b.the_geom)
      AND a.name = 'Hokkaido';

```

Copy to clipboard

In QGIS:

![../../../_images/adjoining_result.png](https://docs.qgis.org/3.28/en/_images/adjoining_result.png)

Note the missing region (Queensland). This may be due to a topology error. Artifacts such as this can alert us to potential problems in the data. To solve this enigma without getting caught up in the anomalies the data may have, we could use a buffer intersect instead:

```
CREATE VIEW vw_hokkaido_buffer AS
  SELECT gid, ST_BUFFER(the_geom, 100) as the_geom
    FROM region
      WHERE name = 'Hokkaido';

```

Copy to clipboard

This creates a buffer of 100 meters around the region Hokkaido.

The darker area is the buffer:

![../../../_images/hokkaido_buffer.png](https://docs.qgis.org/3.28/en/_images/hokkaido_buffer.png)

Select using the buffer:

```
CREATE VIEW vw_hokkaido_buffer_select AS
  SELECT b.gid, b.name, b.the_geom
    FROM
    (
      SELECT * FROM
        vw_hokkaido_buffer
    ) a,
    region b
    WHERE ST_INTERSECTS(a.the_geom, b.the_geom)
    AND b.name != 'Hokkaido';

```

Copy to clipboard

In this query, the original buffer view is used as any other table would be. It is given the alias a, and its geometry field, a.the\_geom, is used to select any polygon in the region table (alias b) that intersects it. However, Hokkaido itself is excluded from this select statement, because we don’t want it; we only want the regions adjoining it.

In QGIS:

![../../../_images/hokkaido_buffer_select.png](https://docs.qgis.org/3.28/en/_images/hokkaido_buffer_select.png)

It is also possible to select all objects within a given distance, without the extra step of creating a buffer:

```
CREATE VIEW vw_hokkaido_distance_select AS
  SELECT b.gid, b.name, b.the_geom
    FROM region a, region b
      WHERE ST_DISTANCE (a.the_geom, b.the_geom) < 100
      AND a.name = 'Hokkaido'
      AND b.name != 'Hokkaido';

```

Copy to clipboard

This achieves the same result, without need for the interim buffer step:

![../../../_images/hokkaido_distance_select.png](https://docs.qgis.org/3.28/en/_images/hokkaido_distance_select.png)

### Select unique values [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/spatial_queries.html#select-unique-values "Permalink to this headline")

Show a list of unique town names for all buildings in the Queensland region:

```
SELECT DISTINCT a.name
  FROM building a, region b
    WHERE st_within(a.the_geom, b.the_geom)
    AND b.name = 'Queensland';

```

Copy to clipboard

Result:

```
  name
---------
 Beijing
 Berlin
 Atlanta
(3 rows)

```

Copy to clipboard

### Further examples … [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/spatial_queries.html#further-examples "Permalink to this headline")

```
CREATE VIEW vw_shortestline AS
  SELECT b.gid AS gid,
        ST_ASTEXT(ST_SHORTESTLINE(a.the_geom, b.the_geom)) as text,
        ST_SHORTESTLINE(a.the_geom, b.the_geom) AS the_geom
    FROM road a, building b
      WHERE a.id=5 AND b.id=22;

CREATE VIEW vw_longestline AS
  SELECT b.gid AS gid,
         ST_ASTEXT(ST_LONGESTLINE(a.the_geom, b.the_geom)) as text,
         ST_LONGESTLINE(a.the_geom, b.the_geom) AS the_geom
    FROM road a, building b
      WHERE a.id=5 AND b.id=22;

```

Copy to clipboard

```
CREATE VIEW vw_road_centroid AS
  SELECT a.gid as gid, ST_CENTROID(a.the_geom) as the_geom
    FROM road a
      WHERE a.id = 1;

CREATE VIEW vw_region_centroid AS
  SELECT a.gid as gid, ST_CENTROID(a.the_geom) as the_geom
    FROM region a
      WHERE a.name = 'Saskatchewan';

```

Copy to clipboard

```
SELECT ST_PERIMETER(a.the_geom)
  FROM region a
    WHERE a.name='Queensland';

SELECT ST_AREA(a.the_geom)
  FROM region a
    WHERE a.name='Queensland';

```

Copy to clipboard

```
CREATE VIEW vw_simplify AS
  SELECT gid, ST_Simplify(the_geom, 20) AS the_geom
    FROM road;

CREATE VIEW vw_simplify_more AS
  SELECT gid, ST_Simplify(the_geom, 50) AS the_geom
    FROM road;

```

Copy to clipboard

```
CREATE VIEW vw_convex_hull AS
  SELECT
    ROW_NUMBER() over (order by a.name) as id,
    a.name as town,
    ST_CONVEXHULL(ST_COLLECT(a.the_geom)) AS the_geom
    FROM building a
    GROUP BY a.name;

```

Copy to clipboard

## 16.4.5. In Conclusion [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/spatial_queries.html#ic "Permalink to this headline")

You have seen how to query spatial objects using the new database functions from PostGIS.

## 16.4.6. What’s Next? [#](https://docs.qgis.org/3.28/en/docs/training_manual/spatial_databases/spatial_queries.html#wn "Permalink to this headline")

Next we’re going to investigate the structures of more complex geometries and how to create them using